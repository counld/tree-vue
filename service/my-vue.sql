-- phpMyAdmin SQL Dump
-- version 4.4.15.10
-- https://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: 2022-10-18 22:34:14
-- 服务器版本： 5.6.50-log
-- PHP Version: 5.6.40

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `my-vue`
--

-- --------------------------------------------------------

--
-- 表的结构 `article`
--

CREATE TABLE IF NOT EXISTS `article` (
  `id` int(11) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL COMMENT '正文',
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '发表时间',
  `hot` tinyint(1) NOT NULL DEFAULT '0' COMMENT '0:非热门 1:热门',
  `hits` int(11) NOT NULL DEFAULT '0' COMMENT '点击量',
  `thumbnail` varchar(255) DEFAULT '' COMMENT '缩略图',
  `category` int(11) NOT NULL,
  `description` varchar(255) DEFAULT '' COMMENT '描述',
  `tag` varchar(20) DEFAULT NULL COMMENT '标签',
  `creatTime` varchar(255) NOT NULL DEFAULT '2022/9/19 17:39:12'
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='文章表';

--
-- 转存表中的数据 `article`
--

INSERT INTO `article` (`id`, `title`, `content`, `time`, `hot`, `hits`, `thumbnail`, `category`, `description`, `tag`, `creatTime`) VALUES
(1, '不只是一个玩具，因为兴趣', '<h3 style="text-align: start;"><a href="http://localhost:8080/" target="">这是一个好看的电视剧</a></h3><p style="text-align: start;">罗素·贝克在不经意间这样说过，一个人即使已登上顶<img src="/upload/img-xuewu1663161818931.jpg" alt="" data-href="" style=""></p><h3 style="text-align: start;"></h3>', '2022-09-20 14:00:06', 0, 5, NULL, 2, '这启发了我， 玩具，发生了会如何，不发生又会如何。 我们不得不面对一个非常尴尬的事实，那就是， 经过上述讨论富兰克林在不经意间这样说过，你热爱生命吗？那么别浪费时间，因为时间是组成生命的材料。带着这句话，我们还要更加慎重的审视这个问题： 就我个人来说，玩具对我的意义，不能不说非常重大', '诗句', ''),
(2, '没有一个人可以丢下', '<h3 style="text-align: start;"><a href="http://localhost:8080/" target="">这是一个好看的电视剧</a></h3><p style="text-align: start;">罗素·贝克在不经意间这样说过，一个人即使已登上顶峰，也仍要自强不息</p><p style="text-align: start;"><img src="/upload/img-xuewu1663210538288.jpg" alt="" data-href="" style=""></p><h3 style="text-align: start;"></h3>', '2022-10-17 03:46:28', 0, 8, NULL, 1, '没有一个人可以丢下的发生，到底需要如何做到，不没有一个人可以丢下的发生，又会如何产生。 伏尔泰在不经意间这样说过，不经巨大的困难，不会有伟大的事业。这不禁令我深思。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 问题的关键究竟为何? 生活中，若没有一个人可以丢下出现了，我们就不得不考虑它出现了的事实', '博文', ''),
(3, '听说你走了', '<h3 style="text-align: start;"></h3><h3 style="text-align: start;"><a href="http://localhost:8080/" target="">玩具的家</a></h3><p style="text-align: start;">但愿你首先学会吃得起苦。这启发了我， 爱尔兰在不经意间这样说过，越</p><p style="text-align: start;"><img src="/upload/img-xuewu1663210932982.jpg" alt="" data-href="" style="width: 469.80px;height: 268.69px;"></p><h3 style="text-align: start;"></h3>', '2022-09-19 02:44:38', 0, 1, NULL, 1, '接受挑战，就可以享受胜利的喜悦。这启发了我， 康德曾经说过，既然我已经踏上这条道路，那么，任何东西都不应妨碍我沿着这条路走下去。这不禁令我深思。 热爱，发生了会如何，不发生又会如何。 就我个人来说，热爱对我的意义，不能不说非常重大。 莫扎特曾经说过，谁和我一样用功，谁就会和我一样成功。我希望诸位也能好好地体会这句话', '诗句', ''),
(4, '成千上万', '<h3 style="text-align: start;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。我希望诸位也能好好地体会这句话。 带着这些问题，我们来审视一下玩具。 要想清楚，玩具，到底是一种怎么样的存在。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 经过上述讨论德国曾经说过，只有在人群中间，才能认识自己。我希望诸位也能好好地体会这句话。 所谓玩具，关键是玩具需要如何写。 既然如此， 卡莱尔曾经说过，过去一切时代的精华尽在书中。这句话语虽然很短，但令我浮想联翩</span></h3><p><img src="/upload/img-xuewu1663211063846.jpg" alt="" data-href="" style="width: 596.80px;height: 335.48px;"/></p><p><span style="color: rgb(48, 49, 51); background-color: rgb(255, 255, 255); font-size: 14px;">但愿你首先学会吃得起苦。这启发了我， 爱尔兰在不经意间这样说过</span></p>', '2022-09-22 12:55:55', 1, 4, NULL, 3, '只有永远躺在泥坑里的人，才不会再掉进坑里。这不禁令我深思。 要想清楚，成千上万，到底是一种怎么样的存在。 培根在不经意间这样说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒', '娱乐', ''),
(5, '记忆下的深刻纹理', '<p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">在这种困难的抉择下，本人思来想去，寝食难安。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 每个人都不得不面对这些问题。 在面对这种问题时， </span><img src="/upload/img-xuewu1663215031825.jpg" alt="" data-href="" style=""/><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 所谓笔记，关键是笔记需要如何写。 要想清楚，笔记，到底是一种怎么样的存在。 易卜生在不经意间这样说过，伟大的事业，需要决心，能力，组织和责任感。这不禁令我深思</span></p>', '2022-09-20 13:52:35', 1, 9, NULL, 4, '就我个人来说，记忆下的深刻纹理对我的意义，不能不说非常重大。 既然如何， 池田大作在不经意间这样说过，不要回避苦恼和困难，挺起身来向它挑战，进而克服它。这不禁令我深思。 记忆下的深刻纹理，发生了会如何，不发生又会如何。 了解清楚记忆下的深刻纹理到底是一种怎么样的存在，是解决一切问题的关键', '笔记', ''),
(6, '文章千百，不如一篇', '<h1><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;">希望的灯一旦熄灭，生活刹那间变成了一片黑暗</span><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; </span></h1><p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; &nbsp; &nbsp; &nbsp;好看的电视剧，发生了会如何，不发生又会如何。 培根在不经意间这样说过，深窥自己的心，而后发觉一切的奇迹在你自己。我希望诸位也能好好地体会这句话。 问题的关键究竟为何? 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 每个人都不得不面对这些问题。 在面对这种问题时， 在这种困难的抉择下，本人思来想去，寝食难安。 莎士比亚曾经说过，人的一生是短的，但如果卑劣地过这一生，就太长了。这不禁令我深思。 总结的来说， 带着这些问题，我们来审视一下好看的电视剧。 而这些并不是完全重要，更加重要的问题是， 我们都知道，只要有意义，那么就必须慎重考虑。 生活中，若好看的电视剧出现了，我们就不得不考虑它出现了的事实。 总结的来说， 了解清楚好看的电视剧到底是一种怎么样的存在，是解决一切问题的关键。 培根曾经说过，合理安排时间，就等于节约时间。我希望诸位也能好好地体会这句话。 既然如此， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 既然如此， 总结的来说， 现在，解决好看的电视剧的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 我们都知道，只要有意义，那么就必须慎重考虑。 黑塞曾经说过，有勇气承担命运这才是英雄好汉。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。 要想清楚，好看的电视剧，到底是一种怎么样的存在。 而这些并不是完全重要，更加重要的问题是</span><img src="https://img2.baidu.com/it/u=2638757321,3286536365&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=560" alt="侯明昊电视剧(侯明昊又迎来4部热剧)" data-href="https://img2.baidu.com/it/u=2638757321,3286536365&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=560" style="width: 603.00px;height: 675.36px;"/></p><p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; &nbsp; &nbsp; &nbsp;俾斯麦在不经意间这样说过，失败是坚忍的最后考验。带着这句话，我们还要更加慎重的审视这个问题： 我们都知道，只要有意义，那么就必须慎重考虑。 好看的电视剧，到底应该如何实现。 佚名在不经意间这样说过，感激每一个新的挑战，因为它会锻造你的意志和品格。这不禁令我深思。 俾斯麦在不经意间这样说过，对于不屈不挠的人来说，没有失败这回事。这不禁令我深思。 那么， 我们不得不面对一个非常尴尬的事实，那就是， 经过上述讨论要想清楚，好看的电视剧，到底是一种怎么样的存在。 我们不得不面对一个非常尴尬的事实，那就是， 那么， 了解清楚好看的电视剧到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 左拉在不经意间这样说过，生活的道路一旦选定，就要勇敢地走到底，决不回头。这句话语虽然很短，但令我浮想联翩。 经过上述讨论就我个人来说，好看的电视剧对我的意义，不能不说非常重大。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 所谓好看的电视剧，关键是好看的电视剧需要如何写</span></p>', '2022-09-19 02:44:43', 0, 1, NULL, 1, '文章千百，不如一篇因何而发生?每个人都不得不面对这些问题。 在面对这种问题时， 既然如何， 维龙在不经意间这样说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。带着这句话，我们还要更加慎重的审视这个问题： 所谓文章千百，不如一篇，关键是文章千百，不如一篇需要如何写。 既然如此， 所谓文章千百，不如一篇，关键是文章千百，不如一篇需要如何写', '博文', ''),
(7, '好笔头不如烂笔头', '<h1><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">伟大的事业，需要决心，能力，组织和责任感</span></h1><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> 俾斯麦在不经意间这样说过，失败是坚忍的最后考验。带着这句话，我们还要更加慎重的审视这个问题： 我们都知道，只要有意义，那么就必须慎重考虑。 好看的电视剧，到底应该如何实现。 佚名在不经意间这样说过，感激每一个新的挑战，因为它会锻造你的意志和品格。这不禁令我深思。 俾斯麦在不经意间这样说过，对于不屈不挠的人</span><img src="https://img2.baidu.com/it/u=2638757321,3286536365&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=560" alt="侯明昊电视剧(侯明昊又迎来4部热剧)" data-href="https://img2.baidu.com/it/u=2638757321,3286536365&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=560" style=""><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">来说，没有失败这回事。这不禁令我深思。 那么， 我们不得不面对一个非常尴尬的事实，那就是， 经过上述讨论要想清楚，好看的电视剧，到底是一种怎么样的存在。 我们不得不面对一个非常尴尬的事实，那就是， 那么， 了解清楚好看的电视剧到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 左拉在不经意间这样说过，生活的道路一旦选定，就要勇敢地走到底，决不回头。这句话语虽然很短，但令我浮想联翩。 经过上述讨论就我个人来说，好看的电视剧对我的意义，不能不说非常重大。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 所谓好看的电视剧，关键是好看的电视剧需要如何写</span></p>', '2022-09-19 02:44:44', 1, 6, NULL, 4, '人的一生是短的，但如果卑劣地过这一生，就太长了', '笔记', ''),
(8, '魅力人生的发生，到底需要如何做到，不魅力人生的发生，又会如何产生', '<h1><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">所谓魅力人生，关键是魅力人生需要如何写。 所谓魅力人生，关键是魅力人生需要如何写。 </span></h1><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">现在，解决魅力人生的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 塞涅卡曾经说过，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这不禁令我深思。 经过上述讨论乌申斯基曾经说过，学习是劳动，是充满思想的劳动。这不禁令我深思。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 魅力人生，到底应该如何实现。 而这些并不是完全重要，更加重要的问题是， 经过上述讨论经过上述讨论在这种困难的抉择下，本人思来想去，寝食难安。 而这些并不是完全重要，更加重要的问题是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下魅力人生。 我们不得不面对一个非常尴尬的事实，那就是， 问题的关键究竟为何? 魅力人生，发生了会如何，不发生又会如何。 所谓魅力人生，关键是魅力人生需要如何写。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 在这种困难的抉择下，本人思来想去，寝食难安。 伏尔泰在不经意间这样说过，不经巨大的困难，不会有伟大的事业。这不禁令我深思。 魅力人生，发生了会如何，不发生又会如何。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 </span><img src="https://img2.baidu.com/it/u=228013751,890397336&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663434000&amp;t=8722845e9e4f2a235abfcf86b37b22dd" alt="美丽人生:一部笑着笑着就哭了的电影,人生旅途的灯塔!" data-href="https://img2.baidu.com/it/u=228013751,890397336&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663434000&amp;t=8722845e9e4f2a235abfcf86b37b22dd" style=""><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">了解清楚魅力人生到底是一种怎么样的存在，是解决一切问题的关键。 了解清楚魅力人生到底是一种怎么样的存在，是解决一切问题的关键。 我认为， 魅力人生的发生，到底需要如何做到，不魅力人生的发生，又会如何产生。 西班牙在不经意间这样说过，自己的鞋子，自己知道紧在哪里。这不禁令我深思。 魅力人生因何而发生?了解清楚魅力人生到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 生活中，若魅力人生出现了，我们就不得不考虑它出现了的事实。 魅力人生的发生，到底需要如何做到，不魅力人生的发生，又会如何产生。 雷锋曾经说过，自己活着，就是为了使别人过得更美好。带着这句话，我们还要更加慎重的审视这个问题： 笛卡儿在不经意间这样说过，读一切好书，就是和许多高尚的人谈话。这句话语虽然很短，但令我浮想联翩。 了解清楚魅力人生到底是一种怎么样的存在，是解决一切问题的关键。</span></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">了解清楚魅力人生到底是一种怎么样的存在，是解决一切问题的关键。 要想清楚，魅力人生，到底是一种怎么样的存在。 魅力人生，发生了会如何，不发生又会如何。 魅力人生因何而发生?塞涅卡在不经意间这样说过，生命如同寓言，其价值不在与长短，而在与内容。这启发了我， 要想清楚，魅力人生，到底是一种怎么样的存在。 问题的关键究竟为何? 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 叔本华曾经说过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。带着这句话，我们还要更加慎重的审视这个问题： 经过上述讨论笛卡儿在不经意间这样说过，读一切好书，就是和许多高尚的人谈话。这启发了我， 培根在不经意间这样说过，深窥自己的心，而后发觉一切的奇迹在你自己。带着这句话，我们还要更加慎重的审视这个问题： 而这些并不是完全重要，更加重要的问题是， 莎士比亚在不经意间这样说过，意志命运往往背道而驰，决心到最后会全部推倒。这句话语虽然很短，但令我浮想联翩。 爱迪生曾经说过，失败也是我需要的，它和成功对我一样有价值。带着这句话，我们还要更加慎重的审视这个问题： 希腊曾经说过，最困难的事情就是认识自己。带着这句话，我们还要更加慎重的审视这个问题： 生活中，若魅力人生出现了，我们就不得不考虑它出现了的事实。 别林斯基曾经说过，好的书籍是最贵重的珍宝。我希望诸位也能好好地体会这句话</span></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">克劳斯·莫瑟爵士在不经意间这样说过，教育需要花费钱，而无知也是一样。这启发了我， 一般来说， 杰纳勒尔·乔治·S·巴顿曾经说过，接受挑战，就可以享受胜利的喜悦。我希望诸位也能好好地体会这句话。 经过上述讨论而这些并不是完全重要，更加重要的问题是， 总结的来说， 既然如此， 鲁巴金在不经意间这样说过，读书是在别人思想的帮助下，建立起自己的思想。这不禁令我深思。 普列姆昌德在不经意间这样说过，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。这启发了我， 歌德在不经意间这样说过，决定一个人的一生，以及整个命运的，只是一瞬之间。这句话语虽然很短，但令我浮想联翩。 我认为， 生活中，若魅力人生出现了，我们就不得不考虑它出现了的事实。 带着这些问题，我们来审视一下魅力人生。 我们都知道，只要有意义，那么就必须慎重考虑。 既然如此， 易卜生曾经说过，伟大的事业，需要决心，能力，组织和责任感。这不禁令我深思。 要想清楚，魅力人生，到底是一种怎么样的存在。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解</span></p>', '2022-09-19 15:57:19', 1, 7, NULL, 3, '莫扎特在不经意间这样说过，谁和我一样用功，谁就会和我一样成功。我希望诸位也能好好地体会这句话。 西班牙在不经意间这样说过，自知之明是最难得的知识。我希望诸位也能好好地体会这句话。 既然如此， 经过上述讨论我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 每个人都不得不面对这些问题。 在面对这种问题时', '娱乐', ''),
(9, '要掌握书，莫被书掌握；要为生而读，莫为读而生', '<p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">生活中，若喜欢出现了，我们就不得不考虑它出现了的事实。 塞内加在不经意间这样说过，勇气通往天堂，怯懦通往地狱。我希望诸位也能好好地体会这句话。 博曾经说过，一次失败，只是证明我们成功的决心还够坚强。 维这不禁令我深思。 池田大作曾经说过，不要回避苦恼和困难，挺起身来向它挑战，进而克服它</span><img src="https://img2.baidu.com/it/u=2911153884,2557580978&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663434000&amp;t=cf4540474cd16e4adabef18ab3c97a2c" alt="喜欢你，不想别的事啦" data-href="https://img2.baidu.com/it/u=2911153884,2557580978&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663434000&amp;t=cf4540474cd16e4adabef18ab3c97a2c" style="width: 594.00px;height: 371.84px;"></p><p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; &nbsp; &nbsp;我们都必须务必慎重的考虑考虑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。带着这句话，我们还要更加慎重的审视这个问题： 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 我们不得不面对一个非常尴尬的事实，那就是， 带着这些问题，我们来审视一下喜欢。 既然如何， 俾斯麦在不经意间这样说过，对于不屈不挠的人来说，没有失败这回事。这句话语虽然很短，但令我浮想联翩。</span></p><p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; &nbsp; &nbsp; &nbsp; 所谓喜欢，关键是喜欢需要如何写。 所谓喜欢，关键是喜欢需要如何写。 了解清楚喜欢到底是一种怎么样的存在，是解决一切问题的关键。 了解清楚喜欢到底是一种怎么样的存在，是解决一切问题的关键。 问题的关键究竟为何? 所谓喜欢，关键是喜欢需要如何写。 带着这些问题，我们来审视一下喜欢。 而这些并不是完全重要，更加重要的问题是， 就我个人来说，喜欢对我的意义，不能不说非常重大。 要想清楚，喜欢，到底是一种怎么样的存在。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 每个人都不得不面对这些问题。 在面对这种问题时， 喜欢因何而发生?所谓喜欢，关键是喜欢需要如何写。</span></p><p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;"> &nbsp; &nbsp; &nbsp; 喜欢，到底是一种怎么样的存在。 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 现在，解决喜欢的问题，是非常非常重要的。 所以， 卢梭曾经说过，浪费时间是一桩大罪过。我希望诸位也能好好地体会这句话。 在这种困难的抉择下，本人思来想去，寝食难安。 我们都知道，只要有意义，那么就必须慎重考虑。 塞涅卡在不经意间这样说过，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。我希望诸位也能好好地体会这句话。 而这些并不是完全重要，更加重要的问题是， 就我个人来说，喜欢对我的意义，不能不说非常重大。 现在，解决喜欢的问题，是非常非常重要的。 所以， 我们不得不面对一个非常尴尬的事实，那就是， 现在，解决喜欢的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 喜欢，发生了会如何，不发生又会如何。 既然如此， 喜欢，到底应该如何实现。 一般来说， 生活中，若喜欢出现了，我们就不得不考虑它出现了的事实。 既然如何， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如何， 要想清楚，喜欢，到底是一种怎么样的存在。 我们不得不面对一个非常尴尬的事实，那就是， 既然如此， 喜欢的发生，到底需要如何做到，不喜欢的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 普列姆昌德曾经说过，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。我希望诸位也能好好地体会这句话。 了解清楚喜欢到底是一种怎么样的存在，是解决一切问题的关键</span></p><p><br></p>', '2022-09-20 12:08:17', 1, 13, '', 1, '学习是劳动，是充满思想的劳动。这句话语虽然很短，但令我浮想联翩。 经过上述讨论了解清楚喜欢到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下喜欢。 问题的关键究竟为何? 佚名在不经意间这样说过，感激每一个新的挑战，因为它会锻造你的意志和品格', '博文', ''),
(10, '闪婚，到底是一种怎么样的存在', '<p><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">闪婚，发生了会如何，不发生又会如何。 总结的来说， 现在，解决闪婚的问题，是非常非</span><img src="https://img1.baidu.com/it/u=593706086,1044776873&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1663434000&t=1f8b25745241b08cda3a04b45739c603" alt="结婚嘿嘿" data-href="https://img1.baidu.com/it/u=593706086,1044776873&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1663434000&t=1f8b25745241b08cda3a04b45739c603" style=""/><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">常重要的。 所以， 生活中，若闪婚出现了，我们就不得不考虑它出现了的事实。 我们都知道，只要有意义，那么就必须慎重考虑。 经过上述讨论一般来说， 培根曾经说过，阅读使人充实，会谈使人敏捷，写作使人精确。我希望诸位也能好好地体会这句话。 我们都知道，只要有意义，那么就必须慎重考虑。 那么， 总结的来说， 就我个人来说，闪婚对我的意义，不能不说非常重大。 池田大作曾经说过，不要回避苦恼和困难，挺起身来向它挑战，进而克服它。带着这句话，我们还要更加慎重的审视这个问题： 带着这些问题，我们来审视一下闪婚</span></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">解决闪婚的问题，是非常非常重要的。 所以， 闪婚，到底应该如何实现。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 生活中，若闪婚出现了，我们就不得不考虑它出现了的事实。 我们不得不面对一个非常尴尬的事实，那就是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 黑塞在不经意间这样说过，有勇气承担命运这才是英雄好汉。我希望诸位也能好好地体会这句话。 我认为， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 生活中，若闪婚出现了，我们就不得不考虑它出现了的事实</span></p><p style="text-indent: 2em;">而这些并不是完全重要，更加重要的问题是， 易卜生在不经意间这样说过，伟大的事业，需要决心，能力，组织和责任感。带着这句话，我们还要更加慎重的审视这个问题： 而这些并不是完全重要，更加重要的问题是， 每个人都不得不面对这些问题。 在面对这种问题时， 我认为， 了解清楚闪婚到底是一种怎么样的存在，是解决一切问题的关键。 既然如此， 既然如此， 总结的来说， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 闪婚的发生，到底需要如何做到，不闪婚的发生，又会如何产生。</p><p><img src="https://img1.baidu.com/it/u=4113649698,3631178832&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1663434000&t=b482d6b135a203a9fb8b903657c3a8e1" alt="快速的闪婚" data-href="https://img1.baidu.com/it/u=4113649698,3631178832&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1663434000&t=b482d6b135a203a9fb8b903657c3a8e1" style="width: 571.00px;height: 412.26px;"/></p><p style="text-indent: 2em;">　　就我个人来说，闪婚对我的意义，不能不说非常重大。 生活中，若闪婚出现了，我们就不得不考虑它出现了的事实。 经过上述讨论左拉曾经说过，生活的道路一旦选定，就要勇敢地走到底，决不回头。我希望诸位也能好好地体会这句话。 闪婚，到底应该如何实现。 那么， 卡莱尔曾经说过，过去一切时代的精华尽在书中。带着这句话，我们还要更加慎重的审视这个问题： 马克思曾经说过，一切节省，归根到底都归结为时间的节省。我希望诸位也能好好地体会这句话。 歌德在不经意间这样说过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 我们不得不面对一个非常尴尬的事实，那就是。</p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">伟大的事业，需要决心，能力，组织和责任感。带着这句话，我们还要更加慎重的审视这个问题： 了解清楚闪婚到底是一种怎么样的存在，是解决一切问题的关键。 而这些并不是完全重要，更加重要的问题是， 我认为， 一般来讲，我们都必须务必慎重的考虑考虑。 现在，解决闪婚的问题，是非常非常重要的。 所以， 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 西班牙在不经意间这样说过，自己的鞋子，自己知道紧在哪里。带着这句话，我们还要更加慎重的审视这个问题： 叔本华在不经意间这样说过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。这启发了我</span></p><p style="text-indent: 2em;"><br></p>', '2022-09-19 17:31:49', 0, 5, '', 3, '失败是坚忍的最后考验。这启发了我， 所谓闪婚，关键是闪婚需要如何写。 了解清楚闪婚到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 德谟克利特在不经意间这样说过，节制使快乐增加并使享受加强。我希望诸位也能好好地体会这句话', '娱乐', ''),
(11, '请看大屏幕', '<p style="text-align: center;"><span style="color: rgb(220, 220, 170);">远看是颗星，</span></p><p style="text-align: center;"><span style="color: rgb(220, 220, 170);">近看象灯笼，</span></p><p style="text-align: center;"><span style="color: rgb(220, 220, 170);">到底是什么，</span></p><p style="text-align: center;"><span style="color: rgb(220, 220, 170);">本来是只虫。</span></p>', '2022-09-19 12:15:47', 0, 8, '', 6, '嘿嘿，看你猜那些', '猜谜语', ''),
(20, '李白诗人', '<p>李白长夜行，</p><p style="text-align: justify;">汉皇重色思倾国，御宇多年求不得。</p><p style="text-align: justify;">杨家有女初长成，养在深闺人未识。</p><p style="text-align: justify;">天生丽质难自弃，一朝选在君王侧。</p><p style="text-align: justify;">回眸一笑百媚生，六宫粉黛无颜色。</p><p style="text-align: justify;"><img src="https://iknow-pic.cdn.bcebos.com/54fbb2fb43166d22c92c8005542309f79152d2cc" alt="长恨歌" data-href="https://iknow-pic.cdn.bcebos.com/54fbb2fb43166d22c92c8005542309f79152d2cc" style="width: 50%;"></p><p style="text-align: justify;">春寒赐浴华清池，温泉水滑洗凝脂。</p><p style="text-align: justify;">侍儿扶起娇无力，始是新承恩泽时。</p><p style="text-align: justify;">云鬓花颜金步摇，芙蓉帐暖度春宵。</p><p style="text-align: justify;">春宵苦短日高起，从此君王不早朝。</p><p style="text-align: justify;">承欢侍宴无闲暇，春从春游夜专夜。</p><p style="text-align: justify;">后宫佳丽三千人，三千宠爱在一身。</p><p style="text-align: justify;">金屋妆成娇侍夜，玉楼宴罢醉和春。</p><p style="text-align: justify;">姊妹弟兄皆列土，可怜光彩生门户。</p><p style="text-align: justify;">遂令天下父母心，不重生男重生女。</p><p style="text-align: justify;">骊宫高处入青云，仙乐风飘处处闻。</p><p style="text-align: justify;">缓歌慢舞凝丝竹，尽日君王看不足。</p><p style="text-align: justify;">渔阳鼙（pí）鼓动地来，惊破霓裳羽衣曲。</p><p style="text-align: justify;">九重城阙烟尘生，千乘万骑西南行。</p><p style="text-align: justify;">翠华摇摇行复止，西出都门百余里。</p><p style="text-align: justify;">六军不发无奈何，宛转蛾眉马前死。</p><p style="text-align: justify;">花钿委地无人收，翠翘金雀玉搔头。</p><p style="text-align: justify;">君王掩面救不得，回看血泪相和流。</p><p style="text-align: justify;">黄埃散漫风萧索，云栈萦纡登剑阁。</p><p style="text-align: justify;">峨嵋山下少人行，旌旗无光日色薄。</p><p style="text-align: justify;">蜀江水碧蜀山青，圣主朝朝暮暮情。</p><p style="text-align: justify;">行宫见月伤心色，夜雨闻铃肠断声。</p><p style="text-align: justify;">天旋地转回龙驭，到此踌躇不能去。</p><p style="text-align: justify;">马嵬坡下泥土中，不见玉颜空死处。</p><p style="text-align: justify;">君臣相顾尽沾衣，东望都门信马归。</p><p style="text-align: justify;">归来池苑皆依旧，太液芙蓉未央柳。</p><p style="text-align: justify;">芙蓉如面柳如眉，对此如何不泪垂？</p><p style="text-align: justify;">春风桃李花开日，秋雨梧桐叶落时。</p><p style="text-align: justify;">西宫南内多秋草，落叶满阶红不扫。</p><p style="text-align: justify;">梨园弟子白发新，椒房阿监青娥老。</p><p style="text-align: justify;">夕殿萤飞思悄然，孤灯挑尽未成眠。</p><p style="text-align: justify;">迟迟钟鼓初长夜，耿耿星河欲曙天。</p><p style="text-align: justify;">鸳鸯瓦冷霜华重，翡翠衾寒谁与共？</p><p style="text-align: justify;">悠悠生死别经年，魂魄不曾来入梦。<br><br></p>', '2022-09-20 10:16:01', 0, 1, '', 3, '这是一位有写问的伙伴，也是一位长者，深邃令人向往', '娱乐', ''),
(21, '谎言生活中真的确确实实存在，不要逃避，不要后怕', '<p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">坚强的信心，能使平凡的人做出惊人的事业。带着这句话，我们还要更加慎重的审视这个问题： 就我个人来说，一个谎言对我的意义，不能不说非常重大。 既然如何， 而这些并不是完全重要，更加重要的问题是， 既然如何， 我认为， 就我个人来说，一个谎言对我的意义，不能不说非常重大。</span></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">苏轼在不经意间这样说过，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。这启发了我， 阿卜·日·法拉兹在不经意间这样说过，学问是异常珍贵的东西，从任何源泉吸收都不可耻。我希望诸位也能好好地体会这句话。 就我个人来说，一个谎言对我的意义，不能不说非常重大。 我们都知道，只要有意义，那么就必须慎重考虑。 问题的关键究竟为何? 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 歌德在不经意间这样说过，决定一个人的一生，以及整个命运的，只是一瞬之间。</span></p><p style="text-indent: 2em;"><img src="https://img1.baidu.com/it/u=3527179764,213384389&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663779600&amp;t=b884a0afc40a3bf85f7df393b335ab8c" alt="善意的谎言" data-href="https://img1.baidu.com/it/u=3527179764,213384389&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1663779600&amp;t=b884a0afc40a3bf85f7df393b335ab8c" style=""></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">解决一个谎言的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 在这种困难的抉择下，本人思来想去，寝食难安。 拉罗什福科曾经说过，我们唯一不会改正的缺点是软弱。这句话语虽然很短，但令我浮想联翩。 经过上述讨论每个人都不得不面对这些问题。 在面对这种问题时， 一般来讲，我们都必须务必慎重的考虑考虑。 生活中，若一个谎言出现了，我们就不得不考虑它出现了的事实。 迈克尔·F·斯特利曾经说过，最具挑战性的挑战莫过于提升自我</span></p><p style="text-indent: 2em;"><span style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;">你活了多少岁不算什么，重要的是你是如何度过这些岁月的。这不禁令我深思。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 而这些并不是完全重要，更加重要的问题是， 一个谎言的发生，到底需要如何做到，不一个谎言的发生，又会如何产生。 现在，解决一个谎言的问题，是非常非常重要的。 所以， 带着这些问题，我们来审视一下一个谎言。 经过上述讨论那么， 了解清楚一个谎言到底是一种怎么样的存在，是解决一切问题的关键。 我们不得不面对一个非常尴尬的事实，那就是， 我们不得不面对一个非常尴尬的事实</span></p>', '2022-09-20 13:50:14', 1, 6, '', 1, '阅读使人充实，会谈使人敏捷，写作使人精确', '博文', ''),
(22, 'test话题', '<p>你才是坏人</p>', '2022-09-20 12:07:54', 0, 4, '', 5, '这是一个坏人', '兴趣', '2022/9/20 18:20:02'),
(23, '输入页面地址访问不了', '<p style="text-align: start;">页面出现空白现象，获取资源路径不对等，我相信以VueJs为<a href="https://so.csdn.net/so/search?q=%E6%8A%80%E6%9C%AF%E6%A0%88&amp;spm=1001.2101.3001.7020" target="_blank">技术栈</a>来进行前端开发的小伙伴或多或少都会遇到这样的问题，我也遇到过，那现在我们就来一一解决这样的问题。</p><p style="text-indent: 2em; text-align: start;">很多时候我们发现辛辛苦苦写的VueJs应用经过打包后在自己本地搭建的服务器上测试没有什么问题，但真正放在服务器上后，会发现或多或少的问题，比如：页面出现空白现象，获取资源路径不对等，我相信以VueJs为技术栈来进行前端开发的小伙伴或多或少都会遇到这样的问题，我也遇到过，那现在我们就来一一解决这样的问题</p><p style="text-align: start;"><strong>如何打包</strong></p><ul style="text-align: start;"><li>基于Vue-Cli,通过npm run build来进行打包的操作</li><li></li></ul><p style="text-align: start;"><strong>如何部署</strong></p><ul style="text-align: start;"><li>将打包出来的资源，基于Vue-Cli的一般是dist目录下有static目录和index.html文件，可以直接将这两个文件扔到服务端</li><li>但有时候，我们会直接将dist文件扔到服务端</li></ul><p style="text-align: start;">出现的问题</p><ul style="text-align: start;"><li>打包到服务器后，出现资源引用路径的问题</li><li>打包到服务器后，出现空白页的问题</li><li>打包到服务器后，出现引入的css的type被拦截转换为"text/plain"问题</li><li>打包到服务器后，出现路由刷新404的问题</li></ul><p style="text-align: start;">出现资源引用路径的解决方案</p><p style="text-align: start;">一般这个问题是由于在webpack配置打包发布的目录造成的。</p><ul style="text-align: start;"><li>情况一.如果是将static与index.html直接放在服务器根目录,也就是说，当前的应用访问的网址如:http://www.abc.com</li><li>解决办法：</li><li>1.配置输出的publiPath:"/"或者"./" </li><li></li></ul><ul style="text-align: start;"><li>情况二.直接将打包后的dist文件放在了服务器的根目录，也就是如果需要访问当前的应用，访问的网址如:http://www.abc.com/dist</li><li>解决办法：</li><li>首先需要在创建路由实例中增加：</li><li></li><li><code>const router = new VueRouter({ </code></li><li><code> </code></li><li><code>mode: ''history'', </code></li><li><code> </code></li><li><code>base: ''/mobile/'', </code></li><li><code> </code></li><li><code>scorllBehavior: () =&gt; ({ </code></li><li><code> </code></li><li><code>y: 0 </code></li><li><code> </code></li><li><code>}), </code></li><li><code> </code></li><li><code>routes </code></li><li><code> </code></li><li><code>}); </code></li><li><code>然后再发布部署</code></li><li><code>1.publiPath:"/dist/"或者"http://www.abc.com/dist/" </code></li><li></li></ul><p style="text-align: start;">出现由于路由的history模式下刷新当前路由出现404的问题</p><p style="text-align: start;">今天做的应用发布到服务器上，发现当刷新当前路由的时候，就会出现404的状况，其实这是</p><p style="text-align: start;">因为当刷新当前页面时候，所需要访问的资源在服务器上找不到，也就是说，我们在VueJs开发应用的过程中，设置路由的路径不是真实存在的路径，并且使用了history模式。</p><ul style="text-align: start;"><li>解决办法</li></ul><p style="text-align: start;">需要后端进行配合,参考https://router.vuejs.org/en/essentials/history-mode.html</p><p style="text-align: start;">出现引入的css的type被拦截转换为"text/plain"问题</p><p style="text-align: start;">这是我开发过程中遇到的感觉很奇葩的问题，我们都知道，一般基于Vue-Cli，通过WebPack打包后的资源不需要更改什么。可是我发现，当我把代码进行上传后，输入网址，看见的页面把我吓坏了，发现所有样式不存在了，第一反应就是认为是自己在进行打包配置过程中出现了什么问题，然后通过fillder进行调试，发现css文件是正确获取到的</p><p style="text-align: start;"><span style="color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;">可以看到，这个css文件的type被拦截转换为"text/plain"，这时候，我又把相关的配置文件看了两遍，后面发现，真的是日了狗了，让我哭一会儿。先上图</span></p><p style="text-align: start;"><img src="https://img-blog.csdnimg.cn/img_convert/53d7edd065e64f8f76829ef661470b9a.png" alt="错误" data-href="https://img-blog.csdnimg.cn/img_convert/53d7edd065e64f8f76829ef661470b9a.png" style=""></p><p style="text-align: start;">我擦，原来是服务器端返回的类型居然是"text/plain"。这个问题很好解决，把这图直接给后端，是不是感觉被坑了/(ㄒoㄒ)/~~。</p><p style="text-align: start;"><strong>我们为什么选择了 VueJS：逐步迁移</strong></p><p style="text-align: start;">综合考虑各方面因素，我们最终选择了 VueJS，但对于我们来说，最重要的决定性因素是：我们看到了一个清晰、可逐步迁移到 VueJS，而又不会破坏发展路径的迁移路径。实际上，我敢打赌，在整个迁移期间，我们的客户都没有注意到什么明显的变化，他们不会知道自己访问的页面中，哪些是 Angular 实现的，哪些是 VueJS 实现的。</p><p style="text-align: start;">Vue 采用了与 ReactJS 相似的技术，基于组件，属性下行事件上行等。它与 AngularJS 在模板引擎方面有着惊人的相似。它就像 AngularJS 和 ReactJS 的优美结合。这让我们觉得完美，因为我们有大量的 AngularJS 模板，而我们的主要问题是 Angular 组件带来的复杂逻辑。</p><p style="text-align: start;">实际上多数时候我们需要做的只是将代码中的 ng- 改为 v-，简直太美妙了!</p><p style="text-align: start;">随着深入，我们越发觉得作出了正确的选择，它解决了我们早期遇到的问题：很好的性能，单文件组件，清晰的代码结构，槽，等等。</p><p style="text-align: start;">而且，在迁移的过程中，由于 Vue 结构的方式(单向数据流，基于组件)，它迫使我们反思和重构代码，而不是继续写烂代码，这简化了我们的代码逻辑。</p><p style="text-align: start;">我还想说的最后一点，我发现 VueJS 的文档写得非常好，结构也非常清晰。这也是我们选择 VueJS 的另一个主要原因。我第一次使用 Vue 的时候，花了 30 分钟来阅读它的文档，立即觉得必须要试试这个东西。</p>', '2022-09-21 16:56:43', 1, 4, '/avatar/img-xuewu_24850.png', 1, 'vue禁止输入地址栏直接访问页面_前端新手 Vue应用部署到服务器的正确方式', '博文', '2022/9/21 16:49:08'),
(24, '使用node服务部署项目，怎么用https去访问页面', '<p>在使用vue中的路由官网</p><p> <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html" target="_blank">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html</a> </p><p>可以查看单页面应用官网，怎么不能直接输入地址访问项目路径</p><p><br></p><p>这个为项目添加域名访问，并且要开启外网映射访问。</p><p><img src="/upload/img-xuewu1663750992839.png" alt="" data-href="" style=""/></p><p>就是通过配置http和https监听服务，做到相关的访问路由，进行反向代理 ，这里配置了ssl证书</p><p>这样就可以通过https访问项目</p><p><img src="/upload/img-xuewu1663751234862.png" alt="" data-href="" style=""/></p><p>配置了ssl证书，这样直接访问当前域名，就可以访问自己的项目 </p><p> &nbsp; &nbsp; &nbsp; 但是这个必须是<span style="color: rgb(235, 144, 58);"><strong>开启了部署服务器的端口防火墙</strong></span></p><p><img src="/upload/img-xuewu1663751453071.png" alt="" data-href="" style=""/></p><p><br></p><p style="text-indent: 2em;">这里注意的是打包项目文件的时候，请求的路由地址，一定是请求的是你要部署时的服务器的域名地址，这里不能请求<span style="color: rgb(8, 151, 156);">你弄的node部署时监听的端口8080，而是直接请求https下的地址</span></p><p style="text-indent: 2em;">不然这只能访问到你部署的html下的页面，其他页面是打不开的。</p><p style="text-indent: 2em;">通过以上的部署意识，这样就可以不访问带有端口号的项目链接了 </p><p style="text-indent: 2em;">这里记录一下文件打包是的项目部署https访问系列</p>', '2022-09-21 09:32:07', 0, 2, '/avatar/img-xuewu_76510.png', 4, 'node部署的项目说起来，还是使用到了反向http代理拦截跳转自己部署的地址', '笔记', '2022/9/21 17:21:30'),
(25, '记录nginx不同访问路径和代理的配置', '<p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p><span style="background-color: rgb(183, 235, 143);">通过nginx配置代理node服务</span></p><p><img src="/upload/img-xuewu1663760494497.png" alt="" data-href="" style=""/></p><p><span style="background-color: rgb(183, 235, 143);"># 进程数量</span></p><p><span style="background-color: rgb(183, 235, 143);">worker_processes 1;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);">events {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 最大连接数量</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;worker_connections 1024;</span></p><p><span style="background-color: rgb(183, 235, 143);">}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);">http {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;include mime.types;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;default_type application/octet-stream;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;sendfile on;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;keepalive_timeout 65;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 演示如何强制http跳转https</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;server {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;listen 80;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;server_name test.com;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# http强制跳转到https</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;rewrite ^(.*)$ https://$server_name$1 permanent;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 演示如何配置微信支付的校验文件</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;server {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;listen 80;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;server_name localhost;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 默认根路径</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location / {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;root index.html;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 微信支付校验文件，可以直接配置访问名称</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/MP_verify_2g3uEjrB5B2LIbNl.txt {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;alias /home/MP_verify_2g3uEjrB5B2LIbNl.txt;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 微信支付校验文件，也可以通过正则配置</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ~^/MP_verify_[a-zA-Z0-9]*\\.(txt)$ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;root /home/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;rewrite ^/home/(.txt)$ /home/$1 last;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 演示root和alias两种配置静态资源的区别</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;server {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;listen 80;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;server_name localhost;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 用root方式，location中的路径会拼加到root的地址后面</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://localhost:8080/files/index.jpg &nbsp; &nbsp;实际访问为：/home/files/index.jpg</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ~^/files/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;root /home/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;index index.html index.htm;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 用alias方式，location中的路径不会拼加到alias的地址后面</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 这请求路径为：http://localhost:8080/files/index.jpg &nbsp; &nbsp;实际访问为：/home/index.jpg</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ~^/files/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;alias /home/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;index index.html index.htm;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 演示请求后台接口代理配置</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;server {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;listen 8080;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;server_name localhost;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;#################### 第一种场景（代理地址不加斜杠） ####################</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际代理为：http://127.0.0.1:8000/api/getUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际指向为：http://127.0.0.1:8000/api/getUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;#################### 第二种场景（代理地址+斜杠） ####################</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际代理为：http://127.0.0.1:8000/getUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际代理为：http://127.0.0.1:8000//getUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;#################### 第三种场景（代理地址+后缀） ####################</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际代理为：http://127.0.0.1:8000/user/getUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000/user;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 请求路径为：http://127.0.0.1:8080/api/getUser &nbsp; 实际代理为：http://127.0.0.1:8000/usergetUser</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/api/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8000/user;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;# 演示前端项目如何部署nginx</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;server {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;listen 8090;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;server_name localhost;</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);">	# 默认访问</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 部署路径：/home/web/my_demo</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 访问路径为：http://localhost:8090/</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location / {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;try_files $uri $uri/ /index.html;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;root /home/web/my_demo/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;index index.html index.htm;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><br></p><p><span style="background-color: rgb(183, 235, 143);">	# 带前缀的访问</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 部署路径：/home/web/my_demo</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 访问路径为：http://localhost:8090/my_demo/</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;# 如果location路径最后没有配置斜杠，则浏览器输入访问地址后，路径最后会自动拼一个斜杠</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;location ^~/my_demo/ {</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;try_files $uri $uri/ /my_demo/index.html;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;proxy_set_header Host $http_host;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;root /home/web/;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp;index index.html index.htm;</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp;}</span></p><p><span style="background-color: rgb(183, 235, 143);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p><span style="background-color: rgb(183, 235, 143);">}</span></p><p><br></p>', '2022-10-02 02:34:54', 0, 8, '/avatar/img-xuewu_18873.png', 4, '通过配置nginx服务代理，这样很好的解决了项目部署的时候，通过node启动的项目服务上下问题，可以更好的提示加载速度吧，毕竟https才有多路加载', '笔记', '2022/9/21 19:42:06'),
(26, '烽火连三月 家书抵万金', '<p>烽火连三月，什么抵万金？ 马上相逢无纸笔，凭君干嘛报平安？ 台风天，长兴路，众人排队干什么？ 火情可以等，什么不能等？</p><p>每个人年轻的时候都曾有过不同的梦想，只不过同一时代的少年，他们的梦想会比较接近。譬如说，五六十年代，少年们梦想着成为科学家、工人或是光荣的解放军战士；七八十年代出生的孩子则大多拥有一个白衣胜雪，来去如风的武侠梦；而当代的年轻人，破碎虚空和穿越就成为了他们的口头禅。</p><p>相较于现代人多姿多彩的想象力，古代读书人的梦想就简单得多了，却也更加执着和坚定。早在汉代，班超就谱写了一曲投笔从戎的壮歌，到了唐代，大诗人杨炯也留下了“宁为百夫长，胜作一书生”的豪言壮语。而比杨炯晚出生四十余年另一位唐朝诗人祖咏也曾明确表示，从军是我最大的梦想。<img src="/upload/img-xuewu1663849082784.jpeg" alt="" data-href="" style=""/></p><p>望蓟门</p><p>祖咏</p><p>燕台一望客心惊，笳鼓喧喧汉将营。</p><p>万里寒光生积雪，三边曙色动危旌。</p><p>沙场烽火连胡月，海畔云山拥蓟城。</p><p>少小虽非投笔吏，论功还欲请长缨。</p><p>题目中的蓟门，在古代指两个地方。名气较大的是指现今的蓟县，唐时又称渔阳，安禄山曾任此地的最高长官，所以留下了“渔阳鼙鼓动地来，惊破霓裳羽衣曲”的诗句</p>', '2022-10-02 02:34:54', 0, 7, NULL, 5, '你要的是自由，还是烽火加薪？', '兴趣', '2022/9/22 下午8:18:42'),
(27, '秋分日忆用济', '<p><span style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">......思念似水！</span></p><p><span style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">遇节思吾子，吟诗对夕曛。</span></p><p><span style="color: rgb(0, 150, 136); background-color: rgb(255, 255, 255);">燕将明日去，秋向此时分</span><span style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">。<br>逆旅空弹铗，生涯只卖文。<br>归帆宜早挂，莫待雪纷纷。</span></p>', '2022-09-24 14:08:19', 1, 3, NULL, 2, '秋天行至一半 一半是内敛，一半是张扬 一半是凉飒，一半是明艳 一半是秋色宜人，一半是千里婵娟 此时的你，是否也有不一样的心情', '诗句', '2022/9/23 21:55:16');
INSERT INTO `article` (`id`, `title`, `content`, `time`, `hot`, `hits`, `thumbnail`, `category`, `description`, `tag`, `creatTime`) VALUES
(28, 'You Don''t Know JS: this & Object Prototypes', '<h1 style="text-align: start;">你不知道的 JS：<em>this</em> &amp; Object Prototypes</h1><h1 style="text-align: start;">第一章：<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>还是那个？</h1><p style="text-align: start;">JavaScript 中最令人困惑的机制之一是<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>关键字。它是一个特殊的标识符关键字，在每个函数的范围内自动定义，但它究竟指的是什么，即使是经验丰富的 JavaScript 开发人员也感到困惑。</p><blockquote style="text-align: start;">任何足够先进的技术都与魔法无异。——亚瑟·克拉克</blockquote><p style="text-align: start;">JavaScript 的<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>机制实际上并没有<em>那么先进，但是开发人员经常在自己的脑海中通过插入“复杂”或“令人困惑”来解释这句话，毫无疑问，如果不缺乏清晰的理解，在你的困惑</em><span style="background-color: var(--color-neutral-muted);"><code>this</code></span>中会显得非常神奇。</p><p style="text-align: start;"><strong>注意：</strong> “this”这个词在一般话语中是一个非常常见的代词。因此，很难确定我们是使用“this”作为代词还是使用它来指代实际的关键字标识符，尤其是口头上。为清楚起见，我将始终使用<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>特殊关键字和“this”或<em>this</em>或 this 来表示。</p><h2 style="text-align: start;">为什么<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>？</h2><p style="text-align: start;">如果这种<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>机制如此混乱，即使对于经验丰富的 JavaScript 开发人员来说，人们也可能想知道它为什么有用？麻烦多过它的价值吗？在我们开始讨论<em>如何</em>之前，我们应该检查一下<em>为什么</em>。</p><p style="text-align: start;">让我们尝试说明 的动机和效用<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>：</p><p style="text-align: start;"><br></p><pre><code >function identify() {\n	return this.name.toUpperCase();\n}\n\nfunction speak() {\n	var greeting = "Hello, I''m " + identify.call( this );\n	console.log( greeting );\n}\n\nvar me = {\n	name: "Kyle"\n};\n\nvar you = {\n	name: "Reader"\n};\n\nidentify.call( me ); // KYLE\nidentify.call( you ); // READER\n\nspeak.call( me ); // Hello, I''m KYLE\nspeak.call( you ); // Hello, I''m READER</code></pre><p style="text-align: start;">如果此代码段的内容让<em>您</em>感到困惑，请不要担心！我们很快就会谈到这一点。只需将这些问题简单地放在一边，这样我们就可以更清楚地研究<em>原因。</em></p><p style="text-align: start;"><em>此代码片段允许对多个上下文( and ) 对象重复使用</em><span style="background-color: var(--color-neutral-muted);"><code>identify()</code></span>and函数，而不需要为每个对象使用单独的函数版本。<span style="background-color: var(--color-neutral-muted);"><code>speak()meyou</code></span></p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>this</code></span>您可以将上下文对象显式传递给<span style="background-color: var(--color-neutral-muted);"><code>identify()</code></span>和，而不是依赖<span style="background-color: var(--color-neutral-muted);"><code>speak()</code></span>。</p><p style="text-align: start;"><br></p><pre><code >function identify(context) {\n	return context.name.toUpperCase();\n}\n\nfunction speak(context) {\n	var greeting = "Hello, I''m " + identify( context );\n	console.log( greeting );\n}\n\nidentify( you ); // READER\nspeak( me ); // Hello, I''m KYLE</code></pre><p style="text-align: start;">但是，该<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>机制提供了一种更优雅的方式来隐式“传递”对象引用，从而实现更简洁的 API 设计和更轻松的重用。</p><p style="text-align: start;">您的使用模式越复杂，您就会越清楚地看到将上下文作为显式参数传递通常比传递<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>上下文更混乱。当我们探索对象和原型时，您将看到能够自动引用正确上下文对象的函数集合的帮助。</p><h2 style="text-align: start;">困惑</h2><p style="text-align: start;">我们很快就会开始解释它<span style="background-color: var(--color-neutral-muted);"><code>this</code></span> <em>实际上是如何工作的，但首先我们必须消除一些关于它</em>实际上是如何工作的误解。</p><p style="text-align: start;">当开发人员试图从字面上考虑它时，“this”这个名字会造成混乱。通常有两种含义，但都是不正确的。</p><h3 style="text-align: start;">本身</h3><p style="text-align: start;">第一个常见的诱惑是假设<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指的是函数本身。至少这是一个合理的语法推断。</p><p style="text-align: start;">为什么要从内部引用函数？最常见的原因是递归（从自身内部调用函数）或具有可以在第一次调用时解除自身绑定的事件处理程序。</p><p style="text-align: start;">不熟悉 JS 机制的开发人员通常认为将函数引用为对象（JavaScript 中的所有函数都是对象！）可以让您在函数调用之间存储<em>状态（属性中的值）。</em>虽然这当然是可能的并且有一些有限的用途，但本书的其余部分将阐述许多其他模式，以便在函数对象之外<em>更好</em>地存储状态。</p><p style="text-align: start;">但是，我们将暂时探索该模式，以说明如何<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>不让函数像我们假设的那样获得对自身的引用。</p><p style="text-align: start;">考虑以下代码，我们尝试跟踪函数 ( <span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>) 被调用的次数：</p><p style="text-align: start;"><br></p><pre><code >function foo(num) {\n	console.log( "foo: " + num );\n\n	// keep track of how many times `foo` is called\n	this.count++;\n}\n\nfoo.count = 0;\n\nvar i;\n\nfor (i=0; i&lt;10; i++) {\n	if (i &gt; 5) {\n		foo( i );\n	}\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\n// how many times was `foo` called?\nconsole.log( foo.count ); // 0 -- WTF?</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>foo.count</code></span><em>仍然</em> 是<span style="background-color: var(--color-neutral-muted);"><code>0</code></span>，尽管这四个<span style="background-color: var(--color-neutral-muted);"><code>console.log</code></span>语句清楚地表明<span style="background-color: var(--color-neutral-muted);"><code>foo(..)</code></span>实际上被调用了四次。挫败感源于对(in ) 含义的<em>过于字面</em>解释。<span style="background-color: var(--color-neutral-muted);"><code>thisthis.count++</code></span></p><p style="text-align: start;">当代码执行<span style="background-color: var(--color-neutral-muted);"><code>foo.count = 0</code></span>时，确实是<span style="background-color: var(--color-neutral-muted);"><code>count</code></span>在函数对象中添加了一个属性<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>。但是对于<span style="background-color: var(--color-neutral-muted);"><code>this.count</code></span>函数内部的引用，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>实际上根本就不是指向<em>那个</em>函数对象，所以即使属性名相同，根对象也不一样，就会产生混乱。</p><p style="text-align: start;"><strong>注意：</strong>负责任的开发人员此时<em>应该</em>问：“如果我正在增加一个<span style="background-color: var(--color-neutral-muted);"><code>count</code></span>属性，但它不是我所期望的，我<span style="background-color: var(--color-neutral-muted);"><code>count</code></span> <em>在</em>增加哪个？” 事实上，如果她深入挖掘，她会发现她不小心创建了一个全局变量<span style="background-color: var(--color-neutral-muted);"><code>count</code></span>（参见第 2 章了解这是<em>怎么</em>回事！），并且它目前的值是<span style="background-color: var(--color-neutral-muted);"><code>NaN</code></span>。当然，一旦她确定了这个特殊的结果，她就会有另外一组问题：“它是如何全局化的，为什么它最终<span style="background-color: var(--color-neutral-muted);"><code>NaN</code></span>不是某个​​适当的计数值？” （见第 2 章）。</p><p style="text-align: start;">许多开发人员没有在这一点停下来深入研究为什么<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>引用似乎没有按<em>预期运行</em>，也没有回答那些棘手但重要的问题，而是完全避免了这个问题，而是转向其他一些解决方案，例如创建另一个对象持有<span style="background-color: var(--color-neutral-muted);"><code>count</code></span>财产：</p><p style="text-align: start;"><br></p><pre><code >function foo(num) {\n	console.log( "foo: " + num );\n\n	// keep track of how many times `foo` is called\n	data.count++;\n}\n\nvar data = {\n	count: 0\n};\n\nvar i;\n\nfor (i=0; i&lt;10; i++) {\n	if (i &gt; 5) {\n		foo( i );\n	}\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\n// how many times was `foo` called?\nconsole.log( data.count ); // 4</code></pre><p style="text-align: start;">虽然这种方法确实“解决”了问题，但不幸的是，它只是忽略了真正的问题——缺乏<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>对它的含义和工作原理的理解——而是退回到更熟悉的机制的舒适区：词法范围。</p><p style="text-align: start;"><strong>注意：</strong>词法作用域是一个非常好的和有用的机制；无论如何，我并不是贬低它的使用（参见本系列丛书的<em>“范围与闭包”标题）。</em>但是不断地<em>猜测</em>如何使用<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>，并且通常是<em>错误</em>的，并不是退回到词汇范围并且永远不知道<em>为什么</em> <span style="background-color: var(--color-neutral-muted);"><code>this</code></span>会逃避你的好理由。</p><p style="text-align: start;">从自身内部引用函数对象<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>通常是不够的。您通常需要通过指向它的词法标识符（变量）来引用函数对象。</p><p style="text-align: start;">考虑这两个函数：</p><p style="text-align: start;"><br></p><pre><code >function foo() {\n	foo.count = 4; // `foo` refers to itself\n}\n\nsetTimeout( function(){\n	// anonymous function (no name), cannot\n	// refer to itself\n}, 10 );</code></pre><p style="text-align: start;">在第一个函数中，称为“命名函数”，<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>是一个引用，可用于从内部引用该函数。</p><p style="text-align: start;">但是在第二个示例中，传递给的函数回调<span style="background-color: var(--color-neutral-muted);"><code>setTimeout(..)</code></span>没有名称标识符（所谓的“匿名函数”），因此没有正确的方法来引用函数对象本身。</p><p style="text-align: start;"><strong>注意：</strong>函数内部的老式但现在已弃用且不受欢迎的<span style="background-color: var(--color-neutral-muted);"><code>arguments.callee</code></span>引用<em>也</em>指向当前执行函数的函数对象。此引用通常是从内部访问匿名函数对象的唯一方法。然而，最好的方法是完全避免使用匿名函数，至少对于那些需要自引用的函数，而是使用命名函数（表达式）。<span style="background-color: var(--color-neutral-muted);"><code>arguments.callee</code></span>已弃用，不应使用。</p><p style="text-align: start;">因此，我们正在运行的示例的另一个解决方案是<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>在每个地方使用标识符作为函数对象引用，并且根本不使用<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>，这很<em>有效</em>：</p><p style="text-align: start;"><br></p><pre><code >function foo(num) {\n	console.log( "foo: " + num );\n\n	// keep track of how many times `foo` is called\n	foo.count++;\n}\n\nfoo.count = 0;\n\nvar i;\n\nfor (i=0; i&lt;10; i++) {\n	if (i &gt; 5) {\n		foo( i );\n	}\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\n// how many times was `foo` called?\nconsole.log( foo.count ); // 4</code></pre><p style="text-align: start;">然而，这种方法同样回避了对 variable 的<em>实际</em>理解，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>并且完全依赖于 variable 的词汇范围<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>。</p><p style="text-align: start;">解决该问题的另一种方法是强制<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>实际指向<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>函数对象：</p><p style="text-align: start;"><br></p><pre><code >function foo(num) {\n	console.log( "foo: " + num );\n\n	// keep track of how many times `foo` is called\n	// Note: `this` IS actually `foo` now, based on\n	// how `foo` is called (see below)\n	this.count++;\n}\n\nfoo.count = 0;\n\nvar i;\n\nfor (i=0; i&lt;10; i++) {\n	if (i &gt; 5) {\n		// using `call(..)`, we ensure the `this`\n		// points at the function object (`foo`) itself\n		foo.call( foo, i );\n	}\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n\n// how many times was `foo` called?\nconsole.log( foo.count ); // 4</code></pre><p style="text-align: start;"><code><strong>我们没有避免this，而是拥抱它。</strong></code>我们将稍微解释一下<em>这些</em>技术是如何更完整地工作的，所以如果您仍然有点困惑，请不要担心！</p><h3 style="text-align: start;">其范围</h3><p style="text-align: start;">下一个关于 of 含义的最常见误解<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>是它以某种方式指代函数的作用域。这是一个棘手的问题，因为从某种意义上说是有道理的，但从另一种意义上说，它是完全被误导的。</p><p style="text-align: start;">需要明确的是，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>它不以任何方式引用函数的<strong>词法范围</strong>。确实，在内部，范围有点像一个对象，每个可用标识符都有属性。但是 JavaScript 代码无法访问范围“对象”。<em>它是Engine</em>实现的内部部分。</p><p style="text-align: start;">考虑尝试（并且失败！）跨越边界并用于<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>隐式引用函数的词法范围的代码：</p><p style="text-align: start;"><br></p><pre><code >function foo() {\n	var a = 2;\n	this.bar();\n}\n\nfunction bar() {\n	console.log( this.a );\n}\n\nfoo(); //undefined</code></pre><p style="text-align: start;">这个片段中有不止一个错误。虽然看起来有些做作，但您看到的代码是在公共社区帮助论坛中交换的实际代码的提炼。<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>这是一个很好的（如果不是悲伤的话）说明错误的假设是多么的好。</p><p style="text-align: start;">首先，尝试<span style="background-color: var(--color-neutral-muted);"><code>bar()</code></span>通过 引用该函数<span style="background-color: var(--color-neutral-muted);"><code>this.bar()</code></span>。它几乎可以肯定是一个<em>意外</em>，但我们将很快解释它是<em>如何</em>工作的。最自然的调用方式<span style="background-color: var(--color-neutral-muted);"><code>bar()</code></span>是省略前导<span style="background-color: var(--color-neutral-muted);"><code>this.</code></span>，只对标识符进行词法引用。</p><p style="text-align: start;">但是，编写此类代码的开发人员正试图在and的词法范围<span style="background-color: var(--color-neutral-muted);"><code>this</code></span><strong>之间建立一座桥梁，以便可以访问. 没有这样的桥梁是不可能的。您不能使用引用在词法范围内查找内容。这不可能。</strong><span style="background-color: var(--color-neutral-muted);"><code>foo()bar()bar()afoo()this</code></span></p><p style="text-align: start;">每次你觉得自己试图将词汇范围查找与 混合时<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>，提醒自己：<em>没有桥梁</em>。</p><h2 style="text-align: start;">是什么<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>？</h2><p style="text-align: start;">抛开各种不正确的假设，现在让我们将注意力转向该<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>机制的真正运作方式。</p><p style="text-align: start;">我们之前说过，这<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>不是作者时绑定，而是运行时绑定。它是基于函数调用条件的上下文。<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>绑定与声明函数的位置无关，而是与调用函数的方式有关。</p><p style="text-align: start;">调用函数时，会创建一个激活记录，也称为执行上下文。此记录包含有关从何处调用函数（调用堆栈）、<em>如何</em>调用函数、传递了哪些参数等信息。此记录的属性之一是<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>将在该持续时间内使用的引用函数的执行。</p><p style="text-align: start;">在下一章中，我们将学习找到一个函数的<strong>调用点</strong>来确定它的执行将如何绑定<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>。</p><h2 style="text-align: start;">审查 (TL;DR)</h2><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>this</code></span>对于没有花时间了解该机制实际工作原理的 JavaScript 开发人员来说，绑定是一个经常性的困惑源。来自 Stack Overflow 答案的猜测、反复试验和盲目复​​制粘贴并不是利用<em>这一</em>重要<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>机制的有效或正确方法。</p><p style="text-align: start;">要学习<span style="background-color: var(--color-neutral-muted);"><code>this</code></span><em>，您首先必须了解什么不是</em><span style="background-color: var(--color-neutral-muted);"><code>this</code></span><em>，尽管有任何假设或误解可能会导致您走上这些道路。既不是对函数本身的引用，也不是对函数词法范围的引用。</em><span style="background-color: var(--color-neutral-muted);"><code>this</code></span></p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>this</code></span>实际上是在调用函数时进行的绑定，它引用的<em>内容</em>完全由调用函数的调用站点确定。</p><p><br></p>', '2022-09-24 15:49:26', 1, 3, NULL, 1, 'JavaScript 中最令人困惑的机制之一是this关键字。它是一个特殊的标识符关键字，在每个函数的范围内自动定义，但它究竟指的是什么，即使是经验丰富的 JavaScript 开发人员也感到困惑', '博文', '2022/9/24 23:35:45'),
(29, '前端学习路线汇总', '<p><br></p><p>JavaScript。重点来了，红宝书看一遍掌握基础，进阶去看《你不知道的 JavaScript》。就这两套足够了，别搞那么多。每个知识点搞懂。ES6基本没啥问题。下面几个问题优搞懂，优先级如下：</p><p><br></p><p><br></p><ol><li>this 用法，相关原理</li><li>原型/原型链</li><li>闭包</li><li>面向对象相关</li><li>同步异步/回调/promise/async、await</li><li>模块化 CommonJS, AMD</li></ol><p><br></p><p><br></p><p>先搞这懂这些比较难的概念，对你JS理解更加深入。接下来在开始看框架方面</p><p><br></p><p><br></p><h3><span style="color: inherit;">二、框架方面</span></h3><p><br></p><p><br></p><p>前期要会用，后期要懂原理。</p><p><br></p><p><br></p><p>新人先搞 Vue。Vue 算是比较简单的框架了，上手容易。照着官方文档来问题不大。原理方面要提高自己认识。学习怎么看源码。github常去逛逛。</p><p><br></p><p><br></p><p>学习框架之前，我其实特别建议，新人先去了解 Babel 和 webpack 不仅仅是使用。一些原理方面的东西工作中也会用到。babel 里面会有教你如何编译代码。webpack教你如和打包文件。自己手写编译器和打包工具也不是特别难。反正对之后看vue、react源码帮助挺大。</p><p><br></p><p><br></p><p>搞完 Vue 全家桶，去了解下 React，React hooks 学习下新的理念。再回过头来看Vue。你会发现他们是如此的相似去又不同。</p><p><br></p><p><br></p><p>多去实践总结，对整体框架理解会越来越深刻。</p><p><br></p><p><br></p><h3><span style="color: inherit;">三、如何看源码</span></h3><p><br></p><p><br></p><p>新人刚开始看源码，会陷入两个困境中。一是无从下手。二是看了之后感觉没啥收获。</p><p><br></p><p><br></p><p>这个也很正常。一般我们熟知的框架都有个几千甚至上万个PR。太大细节会干扰你。掌握整个节奏和流程。学习原理也比较吃力。就连找个入口都像大海捞针一样。建议从下面几个方面入手：</p><p><br></p><p><br></p><ol><li>挑简单的上手。别一开始就搞 vue、react、webpack。太难，会直接劝退新人。不要为了面试而去读。反而效果不好，面试稍微问深入一点就答不出来了。平时有兴趣多琢磨琢磨。按照难易程度，函数库 &lt; 组件库 &lt; 框架 &lt; 工程化 分别典型代表 lodash &lt; vant &lt; vue &lt; webpack</li><li>手撸简易模型。像vue, webpack, babel 都有简易项目给你撸。有的创始人（尤哥）还直播手撸。国外的更多，youtube 一搜一大堆。就算不看源码，照着写出了简易 demo 对原理和理解提升都是很大的。</li><li>调试开源项目。先把项目拉下来。在vscode里面跑下，核心函数多打几个断点。看看里面变量是怎么diff的。对理解更深刻了。</li></ol><p><br></p><p><br></p><p>看了源码是别人的，学到了是自己的。学习时候边记笔记，边思考原理，总结经验。下面来谈谈前端工程化怎么弄。</p><p><br></p><p><br></p><h3><span style="color: inherit;">四、前端工程化</span></h3><p><br></p><p><br></p><p>现在最流行的打包工具 webpack 用起来。当然直接用 vue-cli2、vue-cli3、create-react 都是可以的。但是 webpack 相关还是得掌握。</p><p><br></p><p><br></p><p>首先重点搞下babel、webpack。学习下编译，打包的原理。自己配置下 webpack。尝试自己去写下下 webpack 的 loader 和 plugin。学习这些之前要懂一点 node.js， node.js 不需要全部学习。一般就日常用到读写文件fs接口，path 路径接口。这些 api 都不难写几个 demo 就懂了。基本上webpack 里面配置文件也没用到多少 node 的东西。最后自己学会配置webpack的配置文件。</p><p><br></p><p><br></p><p>如果想深想去优化打包体积和速度，就需要去了解很多webpack插件。webpack 里面最核心的就是插件了。</p><p><br></p><p><br></p><p>当然前端工程化不仅仅是这些，CI/CD可持续集成, Umi 了解下。shell各种脚本自动化命令、代码生成技术了解下。</p><p><br></p><p><br></p><h3><span style="color: inherit;">五、性能优化的方案</span></h3><p><br></p><p><br></p><p>一般来说。性能优化没什么系统化的文档供人学习。完全靠一些经验和自己的实践。</p><p><br></p><p><br></p><p>我们常提到性能好坏是由什么来衡量呢？</p><p><br></p><p><br></p><p>访问页面地址 --&gt; 页面首次加载数据 --&gt; 渲染出完整页面的时长</p><p><br></p><p><br></p><p>非首次情况下，命中缓存的加载缓存数据 --&gt; 渲染出完整页面的时长。</p><p><br></p><p><br></p><p>一般我从下面几个方面着手去做，一般问题都不大。</p><p><br></p><p><br></p><p><span style="color: rgb(123, 12, 0);"><strong>减小资源（静态资源，后端加载的数据）大小</strong></span></p><p><br></p><p><br></p><ul><li>压缩代码HTML/CSS/JS</li><li>压缩图片、音视频大小</li><li>Tree-Sharking 消除无用代码</li></ul><p><br></p><p><br></p><p>以上webpack都可以搞定</p><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>避免同一时间的过多次数请求</strong></span></p><p><br></p><p><br></p><ul><li>CSS 实现雪碧图：使用background-position共享一张图</li><li>图片懒加载：监听滚动后offsetTop, 使用src 替换 src（真实路径）</li><li>列表懒加载（分批加载）：监听滚动后offsetTop， 发送请求加载下一页的数据</li><li>路由懒加载</li><li>代码分包分块加载（webpack）</li><li>预加载技术</li><li>小程序分包、预下载等。</li></ul><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>利用缓存（空间换时间）</strong></span></p><p><br></p><p><br></p><ul><li>CDN 内容分发：获取更近网络节点缓存下来的静态资源</li><li>浏览器缓存（自带）</li><li>部分资源保存在LocalStorage或者APP缓存中（手动操作）</li></ul><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>其他</strong></span></p><p><br></p><p><br></p><ul><li>SSR 服务端渲染：解决SPA框架带来JS动态渲染页面带来的延迟和白屏问题。</li></ul><p><br></p><p><br></p><p>这些都可以去实践的，难度不大。难度大的地方可能是 dom 节点成千上万的时候渲染的性能问题。这个场景遇到的很少，方案很多。不同人有不同解决方案，有功夫可以自己去尝试尝试。</p><p><br></p><p><br></p><p>上面提到很多点都可以深入到很深。由于篇幅原因，点到即止。</p><p><br></p><p><br></p><p>纯粹是把一些我以前走过的弯路掰直了再分享给大家。毕竟不是《前端入门到精通》哈哈哈</p><p><br></p><p><br></p><h3><span style="color: inherit;">六、学习移动端web开发</span></h3><p><br></p><p><br></p><p>前端现在为什么这么火？各个公司都还挺缺优秀的前端。原因在于<span style="color: rgb(119, 48, 152);"><strong>技术红利</strong></span>。</p><p><br></p><p><br></p><p>移动端web流行起来之后，特别是H5和小程序，带动了多少前端就业，前端迅速取代了安卓和iOS 的大量岗位。</p><p><br></p><p><br></p><p>回到正题：所以作为前端人，移动web一般是都要接触的。不同于PC 端。</p><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>移动端有哪些东西呢？</strong></span> 不需要全部懂，差不多知道就行了。要用的时候再去学。</p><p><br></p><p><br></p><ol><li>绝对单位换相对单位：px =&gt; rem / vw / rpx</li><li>弹性布局：使用flex、grid布局</li><li>hairline （1px的粗线处理）：使用伪元素 + transform: scale(倍数) 缩放线框</li><li>WebView 环境了解下</li><li>安卓iOS 兼容踩坑：点击延迟、穿透、滚动不流畅、安全区域等等。</li><li>小程序开发相关踩坑</li><li>JSBridge: H5 与App 通信</li><li>H5动画制作</li><li>跨平台框架：react native、weex、flutter 等等</li></ol><p><br></p><p><br></p><p>简单的说移动web 就是：html/css/js 跑在手机app 里面的WebView（web运行环境）。</p><p><br></p><p><br></p><p>小程序/公众号就是在这个基础上，将自己APP里面的WebView 租售给其他人使用。</p><p><br></p><p><br></p><p>微信APP ----- 提供SDK ----&gt; 微信webview ----- 提供运行环境-----&gt; 公众号h5 / 小程序</p><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>为什么微信可以容纳几乎无限的H5/小程序页面呢？</strong></span></p><p><br></p><p><br></p><p>因为公众号/小程序的代码都存储在云端，通过不同的路由就可以给几乎无数的开发者使用。</p><p><br></p><p><br></p><p>使得微信成为一个运行环境+入口的存在。</p><p><br></p><p><br></p><h3><span style="color: inherit;">七、做前端我有没有觉得吃力？</span></h3><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>刚做时前端不吃力</strong></span>。因为我是软件工程专业，学前端之前，学过 C/C++、Java、PHP、.net 成绩还不错基本都是90多分。感觉自己干后端也不吃力。实验室里面的项目都是前后都写。最爱 PHP，当时最崇拜鸟哥。本以为以后就走上PHP后端工程师的道路了，成为鸟哥那样的大神。</p><p><br></p><p><br></p><p>由于项目需要的原因，后来渐渐开始学起学 HTML、CSS、JavaScript 这些语法相关的东西。刚接触时没有感觉太大难度。</p><p><br></p><p><br></p><p>当时就想着怎么把页面搞好看，搞各种动画炫技。写一个小球从下面弹出来的效果，换各种姿势弹出。当时觉得前端真的有意思，就入了前端的坑。入坑前，以为前端就是搞各种漂亮的页面，各种特性惊艳别人。</p><p><br></p><p><br></p><p>随着接触的越来越深。接触到了 AJAX， jQuery ，Bootstrap，前端开始注重体验。各种框架横空出世 backbone =&gt; Angular =&gt; React =&gt; Vue 眼花缭乱。</p><p><br></p><p><br></p><p>折腾了 JQuery 开始折腾 backbone 觉得前端还能这样玩。有些迷茫了，感觉脑袋快要炸了，那段时间特别焦虑，疯狂看书写代码，怎么这么多东西要学啊。</p><p><br></p><p><br></p><p>JavaScript 也不精通，到原型就不理解了，虽然有C++,JAVA面向对象的知识，但JavaScript 你怎么和别人玩的不是一个套路啊。当时就都用ES6了， 行，学。都用Sass了，行，学。不学也可以，看不懂别人的代码呀。</p><p><br></p><p><br></p><p><span style="color: rgb(119, 48, 152);"><strong>毕业前为准备校招前端工程师，真的很吃力</strong></span>。就怕校招面试时，自己啥都不懂。</p><p><br></p><p><br></p><p>功夫不负有心人，校招时候顺利拿到了自己满意的Offer。记得当时和面试官对答入流，好像找到知音一样。面试官也是过来人，基本能问的都问了。</p><p><br></p><p><br></p><p>拿到Offer之后就去了实习。实习第一个任务：将一个ES6的后台管理系统重构成 Vue2.0 全家桶的项目。有个导师带，但是她和我是不同项目，出了架构以外代码都是自己写。</p><p><br></p><p><br></p><p>这个阶段还是收获了很多：</p><p><br></p><p><br></p><ol><li>git 命令特别熟练。commit、stash、merge/rebase、cherry-pick、push/pull/fetch、reset等等基本都敲都特别多了</li><li>严格了代码规范。Eslint、prettier 都用起来了</li><li>会自己写业务组件，会封装高级组件、写常规页面了。基本上大部分不是特别复杂的交互都ok。难一点多找下资料可以做出来。</li><li>学会管理API了。自己尝试封装了 axios。统一处理错误和弹窗。</li><li>会抽取公共css、JavaScript 函数，编写CSS 变量和JavaScript 常量了</li><li>webpack 能看懂配置文件了。</li></ol><p><br></p><p><br></p><p>实习过后顺利转正。转正之后，换了另外一个导师带，加入到项目组作为一个比较大的项目的核心开发。基本不再做管理系统了。主要做一个saas 平台。涉及比较难的富文本编辑，UI 拖拽生产文章，数据可视化生产报表等等。还写了几个谷歌浏览器插件。</p><p><br></p><p><br></p><ol><li>开始提升写页面效率，写的比较快了。</li><li>研究 webpack 的插件打包编译效率</li><li>研究 babel 编译原理</li><li>研究了 Vue 编译的一些原理</li><li>研究了 一些图表的使用，多半使用的echart。常规图表基本都用过。</li><li>CI & CD 自己去搭建。学了一些 shell 脚本开发。研究了 docker 相关的东西。</li><li>尝试去写基础组件，搭建基础组件库。</li><li>学习 React 相关的语法。</li><li>研究富文本编辑，图片压缩裁剪原理等等</li><li>写一个简单的微信公众号，接触到了 H5 开发。</li></ol><p><br></p><p><br></p><p>工作第一年，基本上主战场在PC 端。**前半年挺吃力，后半年熟练后游刃有余。**会怼产品，会喷设计，会和后端兄弟配合默契。和团队感情也很深了。</p><p><br></p><p><br></p><p>无奈项目由于某些原因终止，团队解散，调到新团队。在老东家工作一年多后，由于个人原因离开去了一家新的的公司，主战场从PC 到了手机。开始接触移动H5、hybrid 开发。</p><p><br></p><p><br></p><h3><span style="color: inherit;">八、学习吃力的原因肯定是学习方法不太正确。总结下一般怎么才能真正学到东西</span></h3><p><br></p><p><br></p><ol><li>详略得当：前端知识太多，抓重点学，不要像背字典一样。</li><li>不要急着写代码，先理清流程（以一个函数为单位，可以先写注释）再写代码。</li><li>看视频看讲解是会误以为自己会了，其实并没有。</li><li>学会总结：一句话可以讲清楚的事情，不要多说一句。减少心智负担。</li><li>不介意复制代码，但是要知道这个代码里面大致实现原理。感兴趣自己重写一个。</li><li>较大的项目，不要急着看代码。可以先把项目跑起来。通过改代码里面的参数来理解里面的核心流程。</li><li>demo 式编程。对于新框架，参考demo来上手更快更容易理解。</li><li>渐进式编程。对于比较复杂的功能/需求。不要想着一气呵成。先实现一个核心，每次往上面加细节，有点像绘画。</li><li>断点单步调试很有用，定位bug会更快。当然有些不易调试的应用选择打log。一次打 log 要多打点，免得打完log,有得再加。</li><li>黑盒太多的项目，实在找不到bug原因。发给同事帮忙看。可能很快就能看出来。当局者迷，旁观者清。(很多时候是拼写的问题)</li></ol>', '2022-09-24 16:07:27', 0, 0, NULL, 1, '学会慢慢向前', '博文', '2022/9/25 00:07:26');
INSERT INTO `article` (`id`, `title`, `content`, `time`, `hot`, `hits`, `thumbnail`, `category`, `description`, `tag`, `creatTime`) VALUES
(30, 'javascript原型链的机制', '<h1 style="text-align: start;">第 5 章：原型</h1><p style="text-align: start;">在第 3 章和第 4 章中，我们<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>多次提到链，但没有说明它到底是什么。我们现在将详细检查原型。</p><p style="text-align: start;"><strong>注意：</strong>所有模拟类复制行为的尝试，如前面在第 4 章中描述的，被标记为“mixins”的变体，完全绕过了<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>我们在本章中研究的链机制。</p><h2 style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span></h2><p style="text-align: start;">JavaScript 中的对象有一个内部属性，在规范中表示为<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>，它只是对另一个对象的引用。几乎所有对象在<span style="background-color: var(--color-neutral-muted);"><code>null</code></span>创建时都被赋予了该属性的非值。</p><p style="text-align: start;"><strong>注意：</strong>我们很快就会看到一个对象<em>有</em>可能有一个空的<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接，尽管这种情况不太常见。</p><p style="text-align: start;">考虑：</p><p style="text-align: start;"><br></p><pre><code >var myObject = {\n	a: 2\n};\n\nmyObject.a; // 2</code></pre><p style="text-align: start;">参考是做什么<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>用的？在第 3 章中，我们检查了<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>当您引用对象上的属性时调用的操作，例如<span style="background-color: var(--color-neutral-muted);"><code>myObject.a</code></span>. 对于该默认<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>操作，第一步是检查对象本身是否具有属性<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>，如果有，则使用它。</p><p style="text-align: start;"><strong>注意：</strong> ES6 代理超出了本书的讨论范围（将在本系列的后面一本书中介绍！），但是我们在这里讨论的关于正常<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>和<span style="background-color: var(--color-neutral-muted);"><code>[[Put]]</code></span>行为的所有内容都不适用于<span style="background-color: var(--color-neutral-muted);"><code>Proxy</code></span>涉及 a 的情况。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>a</code></span> <strong>但是，如果不</strong>存在会发生什么<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>让我们现在将注意力转移到<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>对象的链接上。</p><p style="text-align: start;">如果无法直接在对象上找到请求的属性，则默认<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>操作会继续跟踪对象的<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span> <strong>链接。</strong></p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	a: 2\n};\n\n// create an object linked to `anotherObject`\nvar myObject = Object.create( anotherObject );\n\nmyObject.a; // 2</code></pre><p style="text-align: start;"><strong>注意：</strong>我们将<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>很快解释它是做什么的，以及它是如何运作的。现在，假设它创建了一个带有<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>我们正在检查的指定对象的链接的对象。</p><p style="text-align: start;">所以，我们<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>现在已经<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接到<span style="background-color: var(--color-neutral-muted);"><code>anotherObject</code></span>. 显然<span style="background-color: var(--color-neutral-muted);"><code>myObject.a</code></span>实际上并不存在，但尽管如此，属性访问成功（而是找到<span style="background-color: var(--color-neutral-muted);"><code>anotherObject</code></span>）并且确实找到了 value <span style="background-color: var(--color-neutral-muted);"><code>2</code></span>。</p><p style="text-align: start;">但是，如果在任何一个<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>上都没有找到<span style="background-color: var(--color-neutral-muted);"><code>anotherObject</code></span>，则它的<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链（如果非空）会再次被查询和跟踪。</p><p style="text-align: start;">这个过程一直持续到找到匹配的属性名称，或者<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链结束。如果在链的末尾<em>没有</em>找到匹配的属性，则<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>操作的返回结果是<span style="background-color: var(--color-neutral-muted);"><code>undefined</code></span>.</p><p style="text-align: start;">与此<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链查找过程类似，如果您使用<span style="background-color: var(--color-neutral-muted);"><code>for..in</code></span>循环来迭代对象，则可以通过其链访问的任何属性（也是<span style="background-color: var(--color-neutral-muted);"><code>enumerable</code></span>——参见第 3 章）将被枚举。如果使用<span style="background-color: var(--color-neutral-muted);"><code>in</code></span>运算符来测试对象上是否存在属性，<span style="background-color: var(--color-neutral-muted);"><code>in</code></span>将检查对象的整个链（不考虑<em>可枚举</em>性）。</p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	a: 2\n};\n\n// create an object linked to `anotherObject`\nvar myObject = Object.create( anotherObject );\n\nfor (var k in myObject) {\n	console.log("found: " + k);\n}\n// found: a\n\n("a" in myObject); // true</code></pre><p style="text-align: start;">因此，<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>当您以各种方式执行属性查找时，会一次咨询一个链接。一旦找到属性或链结束，查找就会停止。</p><h3 style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span></h3><p style="text-align: start;">但是链条<em>到底在哪里</em>“<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>结束”？</p><p style="text-align: start;">每个<em>普通</em> <span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链的顶端是内置的<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>. 这个对象包括在 JS 中使用的各种通用实用程序，因为 JavaScript 中的所有普通（内置，不是特定于主机的扩展）对象“都来自”（又名，在其<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链的顶部）该<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>对象。</p><p style="text-align: start;">在这里找到的一些实用程序您可能熟悉 include<span style="background-color: var(--color-neutral-muted);"><code>.toString()</code></span>和<span style="background-color: var(--color-neutral-muted);"><code>.valueOf()</code></span>. 在第 3 章中，我们介绍了另一个：<span style="background-color: var(--color-neutral-muted);"><code>.hasOwnProperty(..)</code></span>. 还有一个<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>你可能不熟悉的函数，但我们将在本章后面讨论，是<span style="background-color: var(--color-neutral-muted);"><code>.isPrototypeOf(..)</code></span>.</p><h3 style="text-align: start;">设置和阴影属性</h3><p style="text-align: start;">回到第 3 章，我们提到在对象上设置属性比仅向对象添加新属性或更改现有属性的值更细微。我们现在将更全面地重新审视这种情况。</p><p style="text-align: start;"><br></p><pre><code >myObject.foo = "bar";</code></pre><p style="text-align: start;">如果<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>对象已经有一个<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>直接存在的普通数据访问器属性，那么分配就像更改现有属性的值一样简单。</p><p style="text-align: start;">如果<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>尚未直接存在于 上<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>，<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>则遍历链，就像<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>操作一样。如果<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>在链中的任何位置都找不到，则按预期将属性<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>直接添加到指定的值。<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span></p><p style="text-align: start;">但是，如果<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>已经存在于链中更高的位置，则<span style="background-color: var(--color-neutral-muted);"><code>myObject.foo = "bar"</code></span>分配可能会出现细微的（也许是令人惊讶的）行为。稍后我们将对此进行更多研究。</p><p style="text-align: start;">如果属性名称<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>既出现在自身上，也出现在从 开始的链<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span><em>的更高级别上，这称为遮蔽。直接位于链上的属性会遮盖在链中显示较高的任何属性，因为查找总是会找到链中最低的属性。</em><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]myObjectfoomyObject</code></span> <span style="background-color: var(--color-neutral-muted);"><code>foomyObject.foofoo</code></span></p><p style="text-align: start;">正如我们刚刚暗示的那样，阴影<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>并不<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>像看起来那么简单。现在，我们将检查<span style="background-color: var(--color-neutral-muted);"><code>myObject.foo = "bar"</code></span><strong>分配尚未直接启动但处于''链的</strong><span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>更高级别时的三个场景：<span style="background-color: var(--color-neutral-muted);"><code>myObjectmyObject[[Prototype]]</code></span></p><ol style="text-align: start;"><li>如果一个普通的数据访问器（参见第 3 章）属性命名<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>在<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链<code><strong>的任何更高位置，并且它没有被标记为只读（writable:false）</strong></code>，那么一个名为的新属性被<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>直接添加到 中<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>，从而产生一个<strong>阴影属性</strong>。</li><li>如果<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>发现 a 在链上更高<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>，但它被标记为<code><strong>只读 ( writable:false)</strong></code>，则该现有属性的设置以及在其上创建阴影属性<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span> <strong>都是不允许的</strong>。如果代码在 中运行<span style="background-color: var(--color-neutral-muted);"><code>strict mode</code></span>，则会抛出错误。否则，属性值的设置将被忽略。无论哪种方式，<strong>都不会出现阴影</strong>。</li><li>如果<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>在链上找到a<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>并且它是一个 setter（参见第 3 章），那么这个 setter 将始终被调用。No<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>将被添加到 (aka, shadowed on) <span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>，<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>setter 也不会被重新定义。</li></ol><p style="text-align: start;">大多数开发人员认为，<span style="background-color: var(--color-neutral-muted);"><code>[[Put]]</code></span>如果属性已经存在于链的更高位置，则分配属性 ( ) 将始终导致遮蔽<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>，但正如您所见，这仅在刚刚描述的三种情况中的一种 (#1) 中是正确的。</p><p style="text-align: start;">如果你想<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>在 #2 和 #3 的情况下隐藏，你不能使用<span style="background-color: var(--color-neutral-muted);"><code>=</code></span>赋值，而必须使用<span style="background-color: var(--color-neutral-muted);"><code>Object.defineProperty(..)</code></span>（参见第 3 章）添加<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>到<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>.</p><p style="text-align: start;"><strong>注意：</strong>案例 #2 可能是三者中最令人惊讶的。<em>只读</em>属性的存在可防止在<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链的较低级别隐式创建（隐藏）同名属性。这种限制的原因主要是为了强化类继承属性的错觉。如果您认为<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>链的更高级别的 已被继承（复制）到，那么在 上强制执行该属性<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span><em>的不可写性质是有意义的。然而，如果你将错觉与事实分开，并认识到实际上并没有发生这样的继承复制（参见第 4 章和第 5 章），那么阻止继承复制就有点不自然了。</em><span style="background-color: var(--color-neutral-muted);"><code>foomyObjectmyObjectfoo</code></span>属性只是因为其他一些对象上有一个不可写的属性<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>。更奇怪的是，这个限制只适用于<span style="background-color: var(--color-neutral-muted);"><code>=</code></span>赋值，但在使用<span style="background-color: var(--color-neutral-muted);"><code>Object.defineProperty(..)</code></span>.</p><p style="text-align: start;">如果您需要在它们之间进行委托，那么使用<strong>方法</strong>遮蔽会导致丑陋<em>的显式伪多态性（参见第 4 章）。</em>通常，阴影比它的价值更复杂和微妙，<strong>所以你应该尽可能避免它</strong>。请参阅第 6 章了解另一种设计模式，其中不鼓励使用阴影，而采用更简洁的替代方案。</p><p style="text-align: start;">阴影甚至可以以微妙的方式隐式发生，因此如果试图避免它，必须小心。考虑：</p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	a: 2\n};\n\nvar myObject = Object.create( anotherObject );\n\nanotherObject.a; // 2\nmyObject.a; // 2\n\nanotherObject.hasOwnProperty( "a" ); // true\nmyObject.hasOwnProperty( "a" ); // false\n\nmyObject.a++; // oops, implicit shadowing!\n\nanotherObject.a; // 2\nmyObject.a; // 3\n\nmyObject.hasOwnProperty( "a" ); // true</code></pre><p style="text-align: start;">虽然看起来<span style="background-color: var(--color-neutral-muted);"><code>myObject.a++</code></span><em>应该（通过委托）查找并只是在适当的位置</em><span style="background-color: var(--color-neutral-muted);"><code>anotherObject.a</code></span>增加属性本身，但操作对应于. 结果是查找属性 via以从中获取当前值，将值加一，然后将值分配给上的新阴影属性。哎呀！<span style="background-color: var(--color-neutral-muted);"><code>++myObject.a = myObject.a + 1[[Get]]a[[Prototype]]2anotherObject.a[[Put]]3amyObject</code></span></p><p style="text-align: start;">处理您修改的委托属性时要非常小心。如果你想增加<span style="background-color: var(--color-neutral-muted);"><code>anotherObject.a</code></span>，唯一正确的方法是<span style="background-color: var(--color-neutral-muted);"><code>anotherObject.a++</code></span>.</p><h2 style="text-align: start;">“班级”</h2><p style="text-align: start;">此时，您可能想知道：“<em>为什么</em>一个对象需要链接到另一个对象？” 真正的好处是什么？这是一个非常合适的问题，但我们必须先了解什么<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>不是，然后<strong>才能</strong>完全理解和欣赏它是什么以及它<em>是</em>如何有用的。</p><p style="text-align: start;">正如我们在第 4 章中解释的那样，在 JavaScript 中，没有像面向类的语言中那样被称为“类”的对象的抽象模式/蓝图。JavaScript<strong>只有</strong>对象。</p><p style="text-align: start;">事实上，JavaScript 在语言中<strong>几乎是独一无二</strong>的，因为它可能是唯一有权使用“面向对象”标签的语言，因为它是可以直接创建对象的非常短的语言列表之一，根本不需要类。</p><p style="text-align: start;">在 JavaScript 中，类不能（因为它们不存在！）描述对象可以做什么。对象直接定义自己的行为。<em><strong>只有对象。</strong></em></p><h3 style="text-align: start;">“类”函数</h3><p style="text-align: start;">JavaScript 中有一种特殊的行为，多年来一直被无耻地滥用以<em>破解看起来</em>像“类”的东西。我们将详细研究这种方法。</p><p style="text-align: start;">特殊的“类类”行为取决于函数的一个奇怪特性：默认情况下，所有函数都有一个公共的、不可枚举的（参见第 3 章）属性，称为<span style="background-color: var(--color-neutral-muted);"><code>prototype</code></span>，它指向一个任意对象。</p><p style="text-align: start;"><br></p><pre><code >function Foo() {\n	// ...\n}\n\nFoo.prototype; // { }</code></pre><p style="text-align: start;">这个对象通常被称为“Foo 的原型”，因为我们通过一个不幸命名的<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>属性引用来访问它。然而，正如我们稍后将看到的那样，这个术语注定会导致我们陷入混乱。相反，我将其称为“以前称为 Foo 的原型的对象”。只是在开玩笑。怎么样：“任意标记为''Foo dot原型''的对象”？</p><p style="text-align: start;">不管我们怎么称呼它，这个对象到底是什么？</p><p style="text-align: start;">最直接的解释方式是，通过调用<span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span>（见第 2 章）创建的每个对象最终都会（有点随意地）<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接到这个“Foo 点原型”对象。</p><p style="text-align: start;">让我们举例说明：</p><p style="text-align: start;"><br></p><pre><code >function Foo() {\n	// ...\n}\n\nvar a = new Foo();\n\nObject.getPrototypeOf( a ) === Foo.prototype; // true</code></pre><p style="text-align: start;">当<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>通过调用创建时<span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span>，其中一件事（所有<em>四个</em>步骤请参见第 2 章）是获取指向对象<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>的内部链接。<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]Foo.prototype</code></span></p><p style="text-align: start;">停下来思考一下这句话的含义。</p><p style="text-align: start;">在面向类的语言中，可以制作一个类的多个<strong>副本（也称为“实例”），例如从模具中冲压出一些东西。</strong>正如我们在第 4 章中看到的，发生这种情况是因为实例化（或继承自）一个类的过程意味着“将行为计划从该类复制到一个物理对象中”，并且对于每个新实例都会再次这样做。</p><p style="text-align: start;">但是在 JavaScript 中，没有执行这样的复制操作。您不会创建一个类的多个实例。您可以创建多个<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span> <em>链接</em>到公共对象的对象。但默认情况下，不会发生复制，因此这些对象最终不会完全分离或彼此断开连接，而是完全<em><strong>链接</strong></em>。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span>产生一个新对象（我们称之为它<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>），并且<strong>该</strong>新对象<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>在内部<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接到该<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象。</p><p style="text-align: start;"><strong>我们最终得到了两个相互关联的对象。</strong>就是<em>这样</em>。我们没有实例化一个类。我们当然没有将行为从“类”复制到具体对象中。我们只是使两个对象相互链接。</p><p style="text-align: start;">事实上，大多数 JS 开发人员都无法理解的秘密在于，<span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span>函数调用实际上与创建链接的过程几乎没有<em>直接关系。</em><strong>这是一种意外的副作用。</strong> <span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span>是一种间接的、迂回的方式来结束我们想要的：<strong>一个链接到另一个对象的新对象</strong>。</p><p style="text-align: start;"><em>我们能以更直接</em>的方式得到我们想要的吗？<strong>是的！</strong>英雄是<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>。但我们稍后会谈到这一点。</p><h4 style="text-align: start;">名字里有什么？</h4><p style="text-align: start;">在 JavaScript 中，我们不会从一个对象（“类”）<em>复制</em>到另一个（“实例”）。我们在对象之间<em>建立联系。</em>对于<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>机制，从视觉上看，箭头从右到左，从下到上移动。</p><p style="text-align: start;">这种机制通常被称为“原型继承”（我们稍后将详细探讨代码），通常被称为“经典继承”的动态语言版本。这是一种尝试在面向类的世界中搭载对“继承”意味着什么的共同理解，但<em>调整</em>（<strong>阅读：铺平</strong>）理解的语义，以适应动态脚本。</p><p style="text-align: start;">“继承”这个词有很强烈的含义（见第四章），有很多先例。仅仅在前面添加“原型”以区分JavaScript 中<em>实际上几乎相反</em>的行为，已经留下了近 20 年的混乱。</p><p style="text-align: start;">我喜欢说，把“原型”贴在“继承”前面，彻底颠倒它的实际含义，就像一只手拿着橙子，另一只手拿着苹果，坚持称苹果为“红橙”。不管我在它前面放什么令人困惑的标签，都不会改变一个水果是苹果，另一个是橙子的<em>事实。</em></p><p style="text-align: start;">更好的方法是简单地将苹果称为苹果——使用最准确和最直接的术语。这使我们更容易理解它们的相似之处和<strong>许多不同</strong>之处，因为我们都对“苹果”的含义有一个简单的、共同的理解。</p><p style="text-align: start;"><em>由于术语的混淆和混淆，我相信标签“原型继承”本身（并试图误用其所有相关的面向类的术语，如“类”、“构造函数”、“实例”、“多态性”，等）在解释 JavaScript 的机制是如何工作的</em><strong>方面弊大于利</strong>。</p><p style="text-align: start;">“继承”意味着<em>复制</em>操作，JavaScript 不复制对象属性（本机默认情况下）。相反，JS 在两个对象之间创建了一个链接，其中一个对象本质上可以将属性/函数访问<em>委托给另一个对象。</em>“委托”（参见第 6 章）对于 JavaScript 的对象链接机制来说是一个更准确的术语。</p><p style="text-align: start;">JavaScript 中有时会出现的另一个术语是“差分继承”。这里的想法是，我们用<em>不同于</em>更一般的描述符的方式来描述对象的行为。例如，您解释说汽车是一种车辆，但它正好有 4 个轮子，而不是重新描述构成普通车辆的所有细节（发动机等）。</p><p style="text-align: start;"><em>如果您尝试将 JS 中的任何给定对象视为可</em>通过委托获得的所有行为的总和，并且<strong>在您的脑海中您将</strong>所有这些行为扁平化为一件有形<em>的事物</em>，那么您可以（有点）了解“差异继承”可能适合。</p><p style="text-align: start;">但就像“原型继承”一样，“差异继承”假装你的心智模型比语言中物理发生的更重要。它忽略了这样一个事实，即对象<span style="background-color: var(--color-neutral-muted);"><code>B</code></span>实际上并不是以差异方式构造的，而是根据定义的特定特征构建的，旁边是没有定义任何东西的“洞”。正是在这些“漏洞”（定义中的空白或缺乏）中，委托<em>可以</em>接管，并在运行中用委托行为“填充”它们。</p><p style="text-align: start;">在本机默认情况下，该对象不会通过“差异继承”的心理模型所暗示的<strong>复制而扁平化为单个差异对象。</strong>因此，“差异继承”并不适合描述 JavaScript<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>机制的实际工作方式。</p><p style="text-align: start;">你<em>可以选择</em>更喜欢“差异继承”的术语和心智模型，作为一个品味问题，但不可否认的是，<em>它只</em>适合你头脑中的心理杂技，而不是引擎中的物理行为。</p><h3 style="text-align: start;">“构造函数”</h3><p style="text-align: start;">让我们回到之前的一些代码：</p><p style="text-align: start;"><br></p><pre><code >function Foo() {\n	// ...\n}\n\nvar a = new Foo();</code></pre><p style="text-align: start;">究竟是什么让我们认为<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>是“阶级”？</p><p style="text-align: start;">一方面，我们看到了<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>关键字的使用，就像面向类的语言在构造类实例时所做的那样。另一方面，看起来我们实际上是在执行一个类的<em>构造</em>方法，因为<span style="background-color: var(--color-neutral-muted);"><code>Foo()</code></span>它实际上是一个被调用的方法，就像实例化该类时调用真实类的构造方法一样。</p><p style="text-align: start;">为了进一步混淆“构造函数”语义，任意标记的<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象还有另一个窍门。考虑这段代码：</p><p style="text-align: start;"><br></p><pre><code >function Foo() {\n	// ...\n}\n\nFoo.prototype.constructor === Foo; // true\n\nvar a = new Foo();\na.constructor === Foo; // true</code></pre><p style="text-align: start;">默认情况下（在代码段第 1 行的声明时！）对象<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>获得一个公共的、不可枚举的（参见第 3 章）属性<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>，称为<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>有关联。此外，我们看到<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>由“构造函数”调用创建的对象<span style="background-color: var(--color-neutral-muted);"><code>new Foo()</code></span> <em>似乎</em>也有一个被调用的属性，该属性<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>同样指向“创建它的函数”。</p><p style="text-align: start;"><strong>注意：</strong>这实际上不是真的。<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>它没有任何<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>属性，尽管<span style="background-color: var(--color-neutral-muted);"><code>a.constructor</code></span>实际上确实解析为<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>函数，但“构造函数”<strong>实际上并不意味着</strong>“被构造”，因为它看起来。我们将很快解释这种奇怪之处。</p><p style="text-align: start;">哦，是的，还有……按照 JavaScript 世界的惯例，“类”以大写字母命名，所以它是“<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>不是”的事实<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>是我们打算将其作为“类”的有力线索。这对你来说很明显，对吧！？</p><p style="text-align: start;"><strong>注意：</strong>这个约定是如此强大，以至于如果你调用一个小写名称的方法，或者如果我们不调用一个恰好以大写字母开头的函数，许多 JS linter 实际上会<em>抱怨。</em><em><strong>那种令人难以置信的是，我们在 JavaScript 中为获得（假的）“面向类”而努力，以至于我们创建了linter 规则以确保我们使用大写字母，即使大写字母对JS引擎。</strong></em><span style="background-color: var(--color-neutral-muted);"><code>newnew</code></span></p><h4 style="text-align: start;">构造函数还是调用？</h4><p style="text-align: start;">在上面的代码片段中，很容易认为这<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>是一个“构造函数”，因为我们调用它<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>并且我们观察到它“构造”了一个对象。</p><p style="text-align: start;">实际上，<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>与程序中的任何其他函数相比，它不再是“构造函数”。函数本身<strong>不是</strong>构造函数。但是，当您将<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>关键字放在普通函数调用之前时，会使该函数调用“构造函数调用”。事实上，<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>有点劫持任何普通函数，并以构造对象的方式调用它，<strong>除了它要执行的任何其他操作</strong>。</p><p style="text-align: start;">例如：</p><p style="text-align: start;"><br></p><pre><code >function NothingSpecial() {\n	console.log( "Don''t mind me!" );\n}\n\nvar a = new NothingSpecial();\n// "Don''t mind me!"\n\na; // {}</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>NothingSpecial</code></span>只是一个普通的老式普通函数，但是当用 调用时<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>，它<em>构造</em>了一个对象，几乎作为副作用，我们碰巧将其分配给<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>. 该<strong>调用</strong>是一个<em>构造函数调用</em>，但<span style="background-color: var(--color-neutral-muted);"><code>NothingSpecial</code></span>它本身并不是一个<em>构造函数</em>。</p><p style="text-align: start;">换句话说，在 JavaScript 中，最恰当的说法是“构造函数”是<code><strong>任何new</strong></code><strong>在其前面使用关键字调用的函数。</strong></p><p style="text-align: start;">函数不是构造函数，但函数调用是“构造函数调用”当且仅当<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>被使用。</p><h3 style="text-align: start;">力学</h3><p style="text-align: start;">这些<em>是</em>JavaScript 中命运多舛的“类”讨论的唯一常见触发因素吗？</p><p style="text-align: start;"><strong>不完全的。</strong>JS 开发人员努力尽可能多地模拟面向类：</p><p style="text-align: start;"><br></p><pre><code >function Foo(name) {\n	this.name = name;\n}\n\nFoo.prototype.myName = function() {\n	return this.name;\n};\n\nvar a = new Foo( "a" );\nvar b = new Foo( "b" );\n\na.myName(); // "a"\nb.myName(); // "b"</code></pre><p style="text-align: start;">这个片段展示了两个额外的“面向类”的技巧：</p><ol style="text-align: start;"><li>this.name = name: 将.name属性添加到每个对象（a和b，分别参见第 2 章关于this绑定的内容），类似于类实例封装数据值的方式。</li><li>Foo.prototype.myName = ...：也许是更有趣的技术，这为对象添加了一个属性（函数）Foo.prototype。现在，a.myName()工作，但也许令人惊讶。如何？</li></ol><p style="text-align: start;">在上面的代码片段中，很容易认为当<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>和<span style="background-color: var(--color-neutral-muted);"><code>b</code></span>被创建时，<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象上的属性/函数会被<em>复制</em>到每个<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>和<span style="background-color: var(--color-neutral-muted);"><code>b</code></span>对象中。<strong>然而，事实并非如此。</strong></p><p style="text-align: start;">在本章的开头，我们解释了<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接，以及如果没有直接在对象上找到属性引用，它如何提供后备查找步骤，作为默认<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>算法的一部分。</p><p style="text-align: start;">因此，根据它们的创建方式，<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>每个<span style="background-color: var(--color-neutral-muted);"><code>b</code></span>最终都<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>与<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>. 分别在或<span style="background-color: var(--color-neutral-muted);"><code>myName</code></span>上找不到时，而是在 上找到（通过委托，参见第 6 章）。<span style="background-color: var(--color-neutral-muted);"><code>abFoo.prototype</code></span></p><h4 style="text-align: start;">“构造函数”Redux</h4><p style="text-align: start;">回想一下之前关于<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>属性的讨论，它<em>看起来</em>是<span style="background-color: var(--color-neutral-muted);"><code>a.constructor === Foo</code></span>真的意味着它上面<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>有一个实际的<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>属性，指向<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>? <strong>不正确。</strong></p><p style="text-align: start;">这只是不幸的混乱。实际上，<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>引用也被<em>委托</em>给，默认情况下<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>，它<strong>恰好</strong><span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>有一个指向<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>。</p><p style="text-align: start;">“由”构造的对象可以访问指向 的属性，这<em>似乎非常方便。但这只不过是一种虚假的安全感。这是一个令人愉快的意外，几乎是切线的，恰好通过这个默认委托指向。实际上，命运多舛的意义假设“是由”构建的，实际上有几种方式可以反过来咬你。</em><span style="background-color: var(--color-neutral-muted);"><code>aFoo.constructorFooa.constructor</code></span> <span style="background-color: var(--color-neutral-muted);"><code>Foo[[Prototype]].constructor</code></span></p><p style="text-align: start;">一方面，默认情况下，on<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>属性仅存在于声明函数时创建的对象上。如果您创建一个新对象，并替换一个函数的默认对象引用，则默认情况下新对象不会神奇地得到它。<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototypeFoo.prototype.constructor</code></span></p><p style="text-align: start;">考虑：</p><p style="text-align: start;"><br></p><pre><code >function Foo() { /* .. */ }\n\nFoo.prototype = { /* .. */ }; // create a new prototype object\n\nvar a1 = new Foo();\na1.constructor === Foo; // false!\na1.constructor === Object; // true!</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Object(..)</code></span>没有“建造”<span style="background-color: var(--color-neutral-muted);"><code>a1</code></span>吗？它确实看起来像是<span style="background-color: var(--color-neutral-muted);"><code>Foo()</code></span>“构建”了它。许多开发人员认为<span style="background-color: var(--color-neutral-muted);"><code>Foo()</code></span>是在进行构造，但是当您认为“构造器”意味着“由”构造时，一切都崩溃了，因为按照这种推理，<span style="background-color: var(--color-neutral-muted);"><code>a1.constructor</code></span>应该是<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>，但事实并非如此！</p><p style="text-align: start;">发生了什么？<span style="background-color: var(--color-neutral-muted);"><code>a1</code></span>没有<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>属性，因此它将<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链向上委托给<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>. 但是该对象没有任何一个<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>（就像默认<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象一样！），所以它一直委托，这次到<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>委托链的顶部。<em>该</em>对象确实有一个<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>，它指向内置<span style="background-color: var(--color-neutral-muted);"><code>Object(..)</code></span>函数。</p><p style="text-align: start;"><strong>误会，破案。</strong></p><p style="text-align: start;">当然，您可以添加<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>回<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象，但这需要手动操作，特别是如果您想匹配本机行为并使其不可枚举（参见第 3 章）。</p><p style="text-align: start;">例如：</p><p style="text-align: start;"><br></p><pre><code >function Foo() { /* .. */ }\n\nFoo.prototype = { /* .. */ }; // create a new prototype object\n\n// Need to properly "fix" the missing `.constructor`\n// property on the new object serving as `Foo.prototype`.\n// See Chapter 3 for `defineProperty(..)`.\nObject.defineProperty( Foo.prototype, "constructor" , {\n	enumerable: false,\n	writable: true,\n	configurable: true,\n	value: Foo    // point `.constructor` at `Foo`\n} );</code></pre><p style="text-align: start;">这需要大量的手动工作来修复<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>。此外，我们真正在做的只是让“constructor”意味着“被构建”的误解永久化。那是一种<em>昂贵</em>的错觉。</p><p style="text-align: start;">事实是，<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>在一个对象上，默认情况下，任意指向一个函数，该函数具有对对象的引用——它调用的引用<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>。“构造函数”和“原型”这两个词只有一个松散的默认含义，以后可能会或可能不会成立。最好的办法是提醒自己，“constructor 并不意味着constructed by”。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>不是神奇的不可变属性。它<em>是</em>不可枚举的（参见上面的片段），但它的值是可写的（可以更改），此外，您可以（有意或无意地）在任何链中的<span style="background-color: var(--color-neutral-muted);"><code>constructor</code></span>任何对象上添加或覆盖名称的属性，具有任何值<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>你觉得合适。</p><p style="text-align: start;">凭借<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>算法遍历<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链的方式，<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>在任何地方找到的属性引用的解析可能与您预期的完全不同。</p><p style="text-align: start;">看看它的含义实际上是多么随意？</p><p style="text-align: start;">结果？一些任意的对象属性引用，例如<span style="background-color: var(--color-neutral-muted);"><code>a1.constructor</code></span>实际上不能被<em>认为</em>是假定的默认函数引用。此外，正如我们稍后将看到的，仅仅通过简单的遗漏，<span style="background-color: var(--color-neutral-muted);"><code>a1.constructor</code></span>甚至可能最终指向一个非常令人惊讶和不明智的地方。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>是极其不可靠的，并且是在您的代码中依赖的不安全引用。<strong>通常，应尽可能避免此类引用。</strong></p><h2 style="text-align: start;">“（原型）继承”</h2><p style="text-align: start;">我们已经看到了一些“类”机制的近似值，它们通常被入侵到 JavaScript 程序中。但是，如果我们没有“继承”的近似值，JavaScript 的“类”将是相当空洞的。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>a</code></span>实际上，当我们能够“继承自”时，我们已经看到了通常称为“原型继承”的机制，<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>从而可以访问该<span style="background-color: var(--color-neutral-muted);"><code>myName()</code></span>函数。但我们传统上认为“继承”是两个“类”之间的关系，而不是“类”和“实例”之间的关系。</p><p style="text-align: start;">回想一下前面的这个图，它不仅显示了从对象（也称为“实例”）<span style="background-color: var(--color-neutral-muted);"><code>a1</code></span>到 object的委托，而且还显示了<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>从<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype</code></span>to的委托<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>，这有点类似于父子类继承的概念。<em>类似于</em>，当然除了箭头的方向，它显示这些是委托链接而不是复制操作。</p><p style="text-align: start;">而且，这是创建此类链接的典型“原型样式”代码：</p><p style="text-align: start;"><br></p><pre><code >function Foo(name) {\n	this.name = name;\n}\n\nFoo.prototype.myName = function() {\n	return this.name;\n};\n\nfunction Bar(name,label) {\n	Foo.call( this, name );\n	this.label = label;\n}\n\n// here, we make a new `Bar.prototype`\n// linked to `Foo.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// Beware! Now `Bar.prototype.constructor` is gone,\n// and might need to be manually "fixed" if you''re\n// in the habit of relying on such properties!\n\nBar.prototype.myLabel = function() {\n	return this.label;\n};\n\nvar a = new Bar( "a", "obj a" );\n\na.myName(); // "a"\na.myLabel(); // "obj a"</code></pre><p style="text-align: start;"><strong>注意：</strong>要理解上述代码片段中为什么<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向，请参阅第 2 章。<span style="background-color: var(--color-neutral-muted);"><code>a</code></span></p><p style="text-align: start;">重要的部分是<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype = Object.create( Foo.prototype )</code></span>。凭空<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span> <em>创建</em><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>一个“新”对象，并将该新对象的内部链接到您指定的对象（<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>在本例中）。</p><p style="text-align: start;">换句话说，该行表示：“创建一个<em>新</em>的 ''Bar dot prototype'' 对象，该对象链接到 ''Foo dot prototype''。”</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>function Bar() { .. }</code></span>声明时，<span style="background-color: var(--color-neutral-muted);"><code>Bar</code></span>与任何其他函数一样，具有<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>指向其默认对象的链接。但是<em>那个</em>对象并没有<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>像我们想要的那样链接到。因此，我们创建了一个<em>新</em>的对象，<em>可以</em>根据需要进行链接，从而有效地丢弃原始错误链接的对象。</p><p style="text-align: start;"><strong>注意：</strong>这里一个常见的误解/混淆是以下任何一种方法也<em>可以</em>工作，但它们不会像您期望的那样工作：</p><p style="text-align: start;"><br></p><pre><code >// doesn''t work like you want!\nBar.prototype = Foo.prototype;\n\n// works kinda like you want, but with\n// side-effects you probably don''t want :(\nBar.prototype = new Foo();</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype = Foo.prototype</code></span>不会创建<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype</code></span>要链接到的新对象。它只是对<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype</code></span>的另一个引用<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>，它有效地<span style="background-color: var(--color-neutral-muted);"><code>Bar</code></span>直接链接到与链接<strong>相同的对象</strong> <span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>：<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>。这意味着当您开始分配时，例如<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype.myLabel = ...</code></span>，您修改<strong>的不是单独</strong><em>的</em>对象，而是共享<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>对象本身，这将影响链接到的任何对象<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>。这几乎肯定不是你想要的。如果它<em>是</em>您想要的，那么您可能根本不需要<span style="background-color: var(--color-neutral-muted);"><code>Bar</code></span>，并且应该只使用<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>并使您的代码更简单。</p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype = new Foo()</code></span> <strong>实际上确实</strong><span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>创建了一个新对象，该对象已按照我们的需要适当链接。但是，它使用<span style="background-color: var(--color-neutral-muted);"><code>Foo(..)</code></span>“构造函数调用”来做到这一点。如果该函数有任何副作用（例如记录、更改状态、注册其他对象、<code><strong>将数据属性添加到this</strong></code>等），则这些副作用会在此链接时发生（并且可能针对错误的对象！） ，而不是像预期的那样仅在创建最终的<span style="background-color: var(--color-neutral-muted);"><code>Bar()</code></span>“后代”时。</p><p style="text-align: start;">所以，我们只剩下使用<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>来创建一个正确链接的新对象，但没有调用的副作用<span style="background-color: var(--color-neutral-muted);"><code>Foo(..)</code></span>。轻微的缺点是我们必须创建一个新对象，将旧对象丢弃，而不是修改我们提供的现有默认对象。</p><p style="text-align: start;">如果有一种标准且可靠的方法来修改现有对象的链接，那就<em>太好了。</em>在 ES6 之前，有一种非标准且不完全跨浏览器的方式，通过可设置的<span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>属性。ES6 添加了一个<span style="background-color: var(--color-neutral-muted);"><code>Object.setPrototypeOf(..)</code></span>辅助实用程序，它以标准且可预测的方式完成任务。</p><p style="text-align: start;">并排比较 ES6<span style="background-color: var(--color-neutral-muted);"><code>Bar.prototype</code></span>之前和 ES6 标准化的链接技术：<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span></p><p style="text-align: start;"><br></p><pre><code >// pre-ES6\n// throws away default existing `Bar.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// ES6+\n// modifies existing `Bar.prototype`\nObject.setPrototypeOf( Bar.prototype, Foo.prototype );</code></pre><p style="text-align: start;">忽略该方法的轻微性能劣势（丢弃稍后会被垃圾收集的对象）<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>，它比 ES6+ 方法要短一些，并且可能更容易阅读。但这可能是一种语法清洗。</p><h3 style="text-align: start;">检查“类”关系</h3><p style="text-align: start;">如果你有一个类似的对象<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>并想找出它委托给什么对象（如果有的话）怎么办？检查一个实例（在 JS 中只是一个对象）的继承祖先（JS 中的委托链接）在传统的面向类的环境中通常称为<em>自省</em>（或<em>反射）。</em></p><p style="text-align: start;">考虑：</p><p style="text-align: start;"><br></p><pre><code >function Foo() {\n	// ...\n}\n\nFoo.prototype.blah = ...;\n\nvar a = new Foo();</code></pre><p style="text-align: start;">那么我们如何自省<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>以找出它的“祖先”（委托链接）？第一种方法包含“类”混淆：</p><p style="text-align: start;"><br></p><pre><code >a instanceof Foo; // true</code></pre><p style="text-align: start;">运算符将<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>一个普通对象作为其左侧操作数，将一个<strong>函数</strong>作为其右侧操作数。问题的<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>答案是：<code><strong>在整个[[Prototype]]链中a，任意指向的对象Foo.prototype是否曾经出现过？</strong></code></p><p style="text-align: start;">不幸的是，这意味着您只能查询某个对象 ( <span style="background-color: var(--color-neutral-muted);"><code>a</code></span>) 的“祖先”，如果您有一些<strong>函数</strong>（<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>，及其附加的<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>引用）来测试。如果你有两个任意对象，比如说<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>and <span style="background-color: var(--color-neutral-muted);"><code>b</code></span>，并且想知道<em>这些对象</em><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>是否通过链相互关联，<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>单靠它是无济于事的。</p><p style="text-align: start;"><strong>注意：</strong>如果您使用内置<span style="background-color: var(--color-neutral-muted);"><code>.bind(..)</code></span>实用程序创建一个硬绑定函数（参见第 2 章），则创建的函数将没有<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>属性。使用<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>这样的函数可以透明地替换创建硬绑定函数<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>的<em>目标函数。</em></p><p style="text-align: start;">将硬绑定函数用作“构造函数调用”是相当少见的，但如果这样做，它的行为就像调用了原始<em>目标函数</em>一样，这意味着使用<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>硬绑定函数也会按照原始函数的行为.</p><p style="text-align: start;">这个片段说明了尝试使用“类”语义来推理<strong>两个对象</strong>之间的关系是多么荒谬，并且<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>：</p><p style="text-align: start;"><br></p><pre><code >// helper utility to see if `o1` is\n// related to (delegates to) `o2`\nfunction isRelatedTo(o1, o2) {\n	function F(){}\n	F.prototype = o2;\n	return o1 instanceof F;\n}\n\nvar a = {};\nvar b = Object.create( a );\n\nisRelatedTo( b, a ); // true</code></pre><p style="text-align: start;">在里面<span style="background-color: var(--color-neutral-muted);"><code>isRelatedTo(..)</code></span>，我们借用了一个一次性函数<span style="background-color: var(--color-neutral-muted);"><code>F</code></span>，将其重新赋值<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>为任意指向某个对象<span style="background-color: var(--color-neutral-muted);"><code>o2</code></span>，然后询问是否<span style="background-color: var(--color-neutral-muted);"><code>o1</code></span>是“实例” <span style="background-color: var(--color-neutral-muted);"><code>F</code></span>。显然<span style="background-color: var(--color-neutral-muted);"><code>o1</code></span>它<em>实际上并不是</em>继承或继承甚至构造自<span style="background-color: var(--color-neutral-muted);"><code>F</code></span>，所以应该清楚为什么这种练习是愚蠢和令人困惑的。<strong>问题归结为强加于 JavaScript 的类语义的笨拙</strong>，在这种情况下，正如<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>.</p><p style="text-align: start;">第二种更简洁的<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>反思方法是：</p><p style="text-align: start;"><br></p><pre><code >Foo.prototype.isPrototypeOf( a ); // true</code></pre><p style="text-align: start;">请注意，在这种情况下，我们并不真正关心（甚至<em>不需要</em>）<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>，我们只需要一个<strong>对象</strong>（在我们的例子中，任意标记<span style="background-color: var(--color-neutral-muted);"><code>Foo.prototype</code></span>）来测试另一个<strong>对象</strong>。问题的<span style="background-color: var(--color-neutral-muted);"><code>isPrototypeOf(..)</code></span>答案是：<code><strong>在整个[[Prototype]]链中a，Foo.prototype是否出现过？</strong></code></p><p style="text-align: start;">同样的问题，同样的答案。但是在第二种方法中，我们实际上不需要间接引用一个<strong>函数</strong>（<span style="background-color: var(--color-neutral-muted);"><code>Foo</code></span>），它的<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>属性将被自动查询。</p><p style="text-align: start;">我们<em>只需要</em>两个<strong>对象</strong>来检查它们之间的关系。例如：</p><p style="text-align: start;"><br></p><pre><code >// Simply: does `b` appear anywhere in\n// `c`s [[Prototype]] chain?\nb.isPrototypeOf( c );</code></pre><p style="text-align: start;">请注意，这种方法根本不需要函数（“类”）。<span style="background-color: var(--color-neutral-muted);"><code>b</code></span>它只是直接使用对and的对象引用<span style="background-color: var(--color-neutral-muted);"><code>c</code></span>，并查询它们之间的关系。换句话说，我们<span style="background-color: var(--color-neutral-muted);"><code>isRelatedTo(..)</code></span>上面的实用程序是语言内置的，它被称为<span style="background-color: var(--color-neutral-muted);"><code>isPrototypeOf(..)</code></span>.</p><p style="text-align: start;">我们也可以直接检索<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>对象的。从 ES5 开始，执行此操作的标准方法是：</p><p style="text-align: start;"><br></p><pre><code >Object.getPrototypeOf( a );</code></pre><p style="text-align: start;">你会注意到对象引用是我们所期望的：</p><p style="text-align: start;"><br></p><pre><code >Object.getPrototypeOf( a ) === Foo.prototype; // true</code></pre><p style="text-align: start;">大多数浏览器（不是全部！）也长期支持访问 internal 的非标准替代方式<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>：</p><p style="text-align: start;"><br></p><pre><code >a.__proto__ === Foo.prototype; // true</code></pre><p style="text-align: start;">奇怪的<span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>（直到 ES6 才标准化！）属性“神奇地”检索<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>对象的内部作为参考，如果您想直接检查（甚至遍历：）<span style="background-color: var(--color-neutral-muted);"><code>.__proto__.__proto__...</code></span>链，这非常有用。</p><p style="text-align: start;">正如我们之前看到的<span style="background-color: var(--color-neutral-muted);"><code>.constructor</code></span>,<span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>实际上并不存在于您正在检查的对象上（<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>在我们的运行示例中）。事实上，它<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>与其他常用实用程序（ 、 等）一起<span style="background-color: var(--color-neutral-muted);"><code>.toString()</code></span>存在<span style="background-color: var(--color-neutral-muted);"><code>.isPrototypeOf(..)</code></span>（不可枚举；参见第 2 章）内置于 .</p><p style="text-align: start;">此外，<span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>它看起来像一个属性，但实际上将其视为 getter/setter 更合适（参见第 3 章）。</p><p style="text-align: start;">粗略地说，我们可以设想这样<span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>实现（参见第 3 章的对象属性定义）：</p><p style="text-align: start;"><br></p><pre><code >Object.defineProperty( Object.prototype, "__proto__", {\n	get: function() {\n		return Object.getPrototypeOf( this );\n	},\n	set: function(o) {\n		// setPrototypeOf(..) as of ES6\n		Object.setPrototypeOf( this, o );\n		return o;\n	}\n} );</code></pre><p style="text-align: start;">因此，当我们访问 (retrieve of)<span style="background-color: var(--color-neutral-muted);"><code>a.__proto__</code></span>时，就像调用<span style="background-color: var(--color-neutral-muted);"><code>a.__proto__()</code></span>（调用 getter 函数）一样。即使对象上存在 getter 函数（请参阅第 2 章的绑定规则），<em>该</em>函数调用也有<span style="background-color: var(--color-neutral-muted);"><code>a</code></span>其作为，所以它就像说.<span style="background-color: var(--color-neutral-muted);"><code>thisObject.prototypethisObject.getPrototypeOf( a )</code></span></p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>.__proto__</code></span>也是一个可设置的属性，就像<span style="background-color: var(--color-neutral-muted);"><code>Object.setPrototypeOf(..)</code></span>前面展示的使用 ES6 一样。但是，通常您<code><strong>不应更改[[Prototype]]现有对象的</strong></code>。</p><p style="text-align: start;">在某些框架中使用了一些非常复杂的高级技术，这些技术允许使用诸如“子类化” an 之类的技巧<span style="background-color: var(--color-neutral-muted);"><code>Array</code></span>，但这在一般编程实践中通常不受欢迎，因为它通常会导致<em>更</em>难以理解/维护代码。</p><p style="text-align: start;"><strong>注意：</strong>从 ES6 开始，<span style="background-color: var(--color-neutral-muted);"><code>class</code></span>关键字将允许近似于内置的 like 的“子类化” <span style="background-color: var(--color-neutral-muted);"><code>Array</code></span>。<span style="background-color: var(--color-neutral-muted);"><code>class</code></span>有关ES6 中添加的语法的讨论，请参见附录 A。</p><p style="text-align: start;">唯一的其他狭隘例外（如前所述）是将<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>默认函数<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>对象的 设置为引用其他对象（除了<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>）。这将避免用新的链接对象完全替换该默认对象。否则，<code><strong>最好将对象[[Prototype]]链接视为只读特性</strong></code>，以便以后阅读代码。</p><p style="text-align: start;"><strong>注意：</strong> JavaScript 社区非正式地为双下划线创造了一个术语，特别是在属性中的前导，例如<span style="background-color: var(--color-neutral-muted);"><code>__proto__</code></span>：“dunder”。因此，JavaScript 中的“cool kids”通常发音<span style="background-color: var(--color-neutral-muted);"><code>__proto__</code></span>为“dunder proto”。</p><h2 style="text-align: start;">对象链接</h2><p style="text-align: start;">正如我们现在所看到的，该<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>机制是一个存在于一个对象上的内部链接，它引用了另一个对象。</p><p style="text-align: start;">当对第一个对象进行属性/方法引用时（主要）执行此链接，并且不存在此类属性/方法。在这种情况下，<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接会告诉引擎在链接到的对象上查找属性/方法。反过来，如果该对象不能完成查找，<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>则跟踪它，依此类推。对象之间的这一系列链接形成了所谓的“原型链”。</p><h3 style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Create()</code></span>链接</h3><p style="text-align: start;">我们已经彻底揭穿了为什么 JavaScript 的<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>机制<strong>不像</strong>类，并且我们已经看到它是如何在适当的对象之间创建<em>链接</em>的<strong>。</strong></p><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>机制的意义何在？为什么 JS 开发人员在他们的代码中花费如此多的精力（模拟类）来连接这些链接如此普遍？</p><p style="text-align: start;">还记得我们在本章前面说过的<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>将成为英雄吗？现在，我们准备看看如何。</p><p style="text-align: start;"><br></p><pre><code >var foo = {\n	something: function() {\n		console.log( "Tell me something good..." );\n	}\n};\n\nvar bar = Object.create( foo );\n\nbar.something(); // Tell me something good...</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>创建一个与我们<span style="background-color: var(--color-neutral-muted);"><code>bar</code></span>指定的对象<span style="background-color: var(--color-neutral-muted);"><code>foo</code></span>（那些额外的东西。<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]new.prototype.constructor</code></span></p><p style="text-align: start;"><strong>注意：</strong> <span style="background-color: var(--color-neutral-muted);"><code>Object.create(null)</code></span>创建一个具有空 (aka, <span style="background-color: var(--color-neutral-muted);"><code>null</code></span>)<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接的对象，因此该对象不能在任何地方委托。由于这样的对象没有原型链，<span style="background-color: var(--color-neutral-muted);"><code>instanceof</code></span>操作符（前面解释过）没有什么要检查的，所以它总是会返回<span style="background-color: var(--color-neutral-muted);"><code>false</code></span>。这些特殊的空<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>对象通常被称为“字典”，因为它们通常纯粹用于在属性中存储数据，主要是因为它们不会受到<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链上任何委托属性/函数的可能意外影响，因此是纯粹的平面数据存储。</p><p style="text-align: start;">我们<em>不需要</em>类来在两个对象之间创建有意义的关系。我们唯一应该<strong>真正关心的</strong>是为了委托而链接在一起的对象，并<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>为我们提供了这种链接，而不需要所有的类。</p><h4 style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Object.create()</code></span>填充物</h4><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>在 ES5 中添加。您可能需要支持 ES5 之前的环境（例如旧版 IE），所以让我们看一下一个简单的<strong>部分</strong>polyfill，<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>它为我们提供了即使在那些旧版 JS 环境中也需要的功能：</p><p style="text-align: start;"><br></p><pre><code >if (!Object.create) {\n	Object.create = function(o) {\n		function F(){}\n		F.prototype = o;\n		return new F();\n	};\n}</code></pre><p style="text-align: start;">这个 polyfill 通过使用一次性<span style="background-color: var(--color-neutral-muted);"><code>F</code></span>函数并覆盖其<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>属性以指向我们要链接的对象来工作。然后我们使用<span style="background-color: var(--color-neutral-muted);"><code>new F()</code></span>构造来创建一个新对象，该对象将按照我们指定的方式链接。</p><p style="text-align: start;">到目前为止，这种用法<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>是最常见的用法，因为它是<em>可以</em>填充的部分。标准 ES5 内置<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>提供了一组额外的功能，这对于 ES5 之前的版本是<strong>不可填充</strong>的。因此，这种能力远不常用。为了完整起见，让我们看一下附加功能：</p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	a: 2\n};\n\nvar myObject = Object.create( anotherObject, {\n	b: {\n		enumerable: false,\n		writable: true,\n		configurable: false,\n		value: 3\n	},\n	c: {\n		enumerable: true,\n		writable: false,\n		configurable: false,\n		value: 4\n	}\n} );\n\nmyObject.hasOwnProperty( "a" ); // false\nmyObject.hasOwnProperty( "b" ); // true\nmyObject.hasOwnProperty( "c" ); // true\n\nmyObject.a; // 2\nmyObject.b; // 3\nmyObject.c; // 4</code></pre><p style="text-align: start;"><em>第二个参数通过声明每个新属性的属性描述符</em><span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>来指定要添加到新创建对象的属性名称（参见第 3 章）。因为无法将属性描述符填充到 ES5 之前的版本中，所以这个附加功能也不能被填充。<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span></p><p style="text-align: start;">绝大多数使用<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>使用 polyfill 安全的功能子集，因此大多数开发人员都可以在 ES5 之前的环境中使用<strong>部分 polyfill</strong>。</p><p style="text-align: start;">一些开发人员采取了更严格的观点，即除非可以<em>完全</em>填充，否则不应填充任何函数。由于<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>是那些部分可填充的实用程序之一，因此这种狭义的观点表明，如果您需要使用<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>ES5 之前的环境中的任何功能，而不是 polyfill，您应该使用自定义实用程序，并且不要使用完全的名字<span style="background-color: var(--color-neutral-muted);"><code>Object.create</code></span>。您可以改为定义自己的实用程序，例如：</p><p style="text-align: start;"><br></p><pre><code >function createAndLinkObject(o) {\n	function F(){}\n	F.prototype = o;\n	return new F();\n}\n\nvar anotherObject = {\n	a: 2\n};\n\nvar myObject = createAndLinkObject( anotherObject );\n\nmyObject.a; // 2</code></pre><p style="text-align: start;">我不同意这种严格的意见。<span style="background-color: var(--color-neutral-muted);"><code>Object.create(..)</code></span>我完全支持如上所示的常见部分 polyfill，即使在 ES5 之前的代码中也可以在您的代码中使用它。我会让你自己做决定。</p><h3 style="text-align: start;">链接作为后备？</h3><p style="text-align: start;">可能很容易认为对象之间的这些链接<em>主要</em>为“缺失”的属性或方法提供了一种回退。虽然这可能是一个观察到的结果，但我认为它并不代表正确的思考方式<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>。</p><p style="text-align: start;">考虑：</p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	cool: function() {\n		console.log( "cool!" );\n	}\n};\n\nvar myObject = Object.create( anotherObject );\n\nmyObject.cool(); // "cool!"</code></pre><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>该<span style="background-color: var(--color-neutral-muted);"><code>anotherObject</code></span>代码将凭借<strong>.</strong> <span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>有点“神奇”，更难理解和维护。</p><p style="text-align: start;">这并不是说没有后备是一种合适的设计模式的情况，但它在 JS 中不是很常见或惯用的，所以如果你发现自己这样做了，你可能想退后一步，重新考虑这是否真的合适并且明智的设计。</p><p style="text-align: start;"><strong>注意：</strong>在 ES6 中，引入了一个名为的高级功能<span style="background-color: var(--color-neutral-muted);"><code>Proxy</code></span>，它可以提供某种“未找到方法”类型的行为。<span style="background-color: var(--color-neutral-muted);"><code>Proxy</code></span>超出了本书的范围，但将在<em>“你不懂 JS”</em>系列的后续书中详细介绍。</p><p style="text-align: start;"><strong>不要错过这里重要但微妙的一点。</strong></p><p style="text-align: start;">例如，设计您打算让开发人员调用<span style="background-color: var(--color-neutral-muted);"><code>myObject.cool()</code></span>并使其工作的软件，即使没有<span style="background-color: var(--color-neutral-muted);"><code>cool()</code></span>方法在<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>您的 API 设计中引入一些“魔法”，这对于维护您的软件的未来开发人员来说可能会感到惊讶。</p><p style="text-align: start;">然而，您可以设计您的 API，使其具有较少的“魔力”，但仍然可以利用<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接的力量。</p><p style="text-align: start;"><br></p><pre><code >var anotherObject = {\n	cool: function() {\n		console.log( "cool!" );\n	}\n};\n\nvar myObject = Object.create( anotherObject );\n\nmyObject.doCool = function() {\n	this.cool(); // internal delegation!\n};\n\nmyObject.doCool(); // "cool!"</code></pre><p style="text-align: start;">在这里，我们调用<span style="background-color: var(--color-neutral-muted);"><code>myObject.doCool()</code></span>，这是一个<em>实际存在</em>于 上的方法<span style="background-color: var(--color-neutral-muted);"><code>myObject</code></span>，使我们的 API 设计更加明确（不那么“神奇”）。<em>在内部</em>，我们的实现遵循<strong>委托设计模式</strong>（参见第 6 章），利用<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>委托给<span style="background-color: var(--color-neutral-muted);"><code>anotherObject.cool()</code></span>.</p><p style="text-align: start;">换句话说，如果委托是内部实现细节而不是在您的 API 设计中明确公开，那么委托将不会那么令人惊讶/混淆。我们将在下一章详细阐述<strong>委托。</strong></p><h2 style="text-align: start;">审查 (TL;DR)</h2><p style="text-align: start;">当尝试对不具有该属性的对象进行属性访问时，该对象的内部<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链接定义了<span style="background-color: var(--color-neutral-muted);"><code>[[Get]]</code></span>操作（参见第 3 章）接下来应该查找的位置。这种从对象到对象的级联链接本质上定义了对象的“原型链”（有点类似于嵌套范围链），以遍历以进行属性解析。</p><p style="text-align: start;">所有普通对象都将内置对象<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>作为原型链的顶部（如范围查找中的全局范围），如果在链中之前的任何位置都没有找到属性解析，则属性解析将停止。<span style="background-color: var(--color-neutral-muted);"><code>toString()</code></span>, <span style="background-color: var(--color-neutral-muted);"><code>valueOf()</code></span>, 和其他几个常见的实用程序存在于这个<span style="background-color: var(--color-neutral-muted);"><code>Object.prototype</code></span>对象上，解释了语言中的所有对象如何能够访问它们。</p><p style="text-align: start;">让两个对象相互链接的最常见方法是在<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>函数调用中使用关键字，在它的四个步骤中（参见第 2 章），它会创建一个链接到另一个对象的新对象。</p><p style="text-align: start;">新对象链接到的“另一个对象”恰好是由<span style="background-color: var(--color-neutral-muted);"><code>.prototype</code></span>调用的函数的任意命名属性引用的对象<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>。用 with 调用的函数<span style="background-color: var(--color-neutral-muted);"><code>new</code></span>通常被称为“构造函数”，尽管事实上它们并没有像传统的面向类语言中的<em>构造函数那样实例化一个类。</em></p><p style="text-align: start;">虽然这些 JavaScript 机制看起来类似于传统面向类语言的“类实例化”和“类继承”，但关键区别在于 JavaScript 中没有复制。相反，对象最终通过内部<span style="background-color: var(--color-neutral-muted);"><code>[[Prototype]]</code></span>链相互链接。</p><p style="text-align: start;">由于各种原因，尤其是术语先例，“继承”（和“原型继承”）和所有其他 OO 术语在考虑 JavaScript的<em>实际</em>工作方式时没有意义（不仅仅适用于我们的强迫思维）楷模）。</p><p style="text-align: start;">相反，“委托”是一个更合适的术语，因为这些关系不是<em>副本</em>而是委托<strong>链接</strong>。</p><p style="text-align: start;"><br></p><p style="text-align: start;"><br></p><p><br></p>', '2022-10-02 14:02:44', 0, 4, NULL, 1, 'JavaScript 中的对象有一个内部属性，在规范中表示为[[Prototype]]，它只是对另一个对象的引用。几乎所有对象在null创建时都被赋予了该属性的非值。', '博文', '2022/9/25 00:09:19');
INSERT INTO `article` (`id`, `title`, `content`, `time`, `hot`, `hits`, `thumbnail`, `category`, `description`, `tag`, `creatTime`) VALUES
(31, 'javascript中的this', '<ol style="text-align: start;"><li><span style="background-color: var(--color-neutral-muted);"><code>1. this</code></span>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li><li><span style="background-color: var(--color-neutral-muted);"><code>2. this</code></span> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li><li>3. &nbsp;正因为在执行上下文的创建阶段<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>的指向就已经被确定了，在执行阶段<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向不可再被更改。</li><li>var obj = {</li><li> &nbsp; &nbsp;a: "1891"</li><li>}</li><li></li><li>function func() {</li><li> &nbsp; &nbsp;this = obj; //报错，因为在执行阶段试图修改this的指向</li><li> &nbsp; &nbsp;console.log(this.a);</li><li>}</li><li></li><li>func();</li><li></li></ol><h2 style="text-align: start;">this的指向规则</h2><h3 style="text-align: start;"><strong>1. 默认指向</strong></h3><p style="text-align: start;">独立函数调用（无法应用后面其他指向规则时），<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向全局对象<span style="background-color: var(--color-neutral-muted);"><code>window</code></span><strong>。</strong></p><p style="text-align: start;"><br></p><pre><code >function func() {\n    console.log( this.a ); // this指向全局对象\n}\nvar a = 2;\nfunc(); //&gt;&gt; 2</code></pre><p style="text-align: start;">对于<strong>默认指向</strong>来说，决定<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>会指向<span style="background-color: var(--color-neutral-muted);"><code>undefined</code></span>，否则<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>会指向全局对象。</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  "use strict";//函数体处于严格模式下，this指向undefined\n  console.log(this.a);\n}\n\nvar a = "1891";\n(function() {\n  func(); //&gt;&gt; 报错\n})();\n</code></pre><pre><code >function func() {\n  console.log(this.a);\n}\n\nvar a = "1891";\n(function() {\n  "use strict";\n  func(); //&gt;&gt; 1891\n  //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关\n})();</code></pre><p style="text-align: start;">还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。</p><p style="text-align: start;"><br></p><pre><code >var num = 0;\nclass Obj {\n    constructor(num){\n        this.num = num;\n    }\n    func(){\n        console.log(this.num);\n    }\n    func1(){\n        setTimeout(function () {\n            console.log("setTimeout:"+this.num);\n        }, 1000)\n    }\n    func2(){\n        setInterval(function () {\n            console.log(this.num);\n        }, 2000)\n    }\n}\nvar obj = new Obj(1);\nobj.func();//&gt;&gt; 1　             输出的是obj.num\nobj.func1()//&gt;&gt; setTimeout:0　  输出的是window.num\nobj.func2()//&gt;&gt; 0 0 0 0 ……　    输出的是window.num</code></pre><p style="text-align: start;">可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p><h3 style="text-align: start;"><strong>2. 隐式指向</strong></h3><p style="text-align: start;">隐式指向是日常开发中最常见的指向。</p><p style="text-align: start;">函数体内<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>的指向由调用位置的调用者决定。<code><strong>如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的this指向该对象</strong></code>。</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n  func: func\n};\nobj.func(); //&gt;&gt; 2\n// 找到调用位置，由 obj 对象来调用函数func，\n// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，\n// 所以此时的 this 指向调用 func 函数的 obj 对象。</code></pre><p style="text-align: start;"><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong>，也就是说<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向最靠近被调用函数的对象，离得远的不是。举例来说：</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  console.log(this.a);\n}\n\nvar obj2 = {\n  a: "1891",\n  func: func\n};\n\nvar obj1 = {\n  a: "coffe",\n  obj2: obj2\n};\n\n//此时的 this 指向 obj2 对象，因为obj2离得近！\nobj1.obj2.func(); //&gt;&gt; 1891</code></pre><p style="text-align: start;">再来看看<strong>隐式丢失：</strong></p><p style="text-align: start;"><br></p><pre><code >function func() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: "coffe1891",\n    func: func\n};\n\nvar bar = obj.func; // 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实\n                    // 都指向内存中的函数func本身。\nvar a = "oops, global"; // a 是全局对象window的属性，也是全局变量\nbar(); //&gt;&gt; oops, global\n\n// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，\n// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,\n// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a）</code></pre><h3 style="text-align: start;">3. 显式指向</h3><p style="text-align: start;">JavaScript内置对象<span style="background-color: var(--color-neutral-muted);"><code>Function</code></span>的三个原型方法<span style="background-color: var(--color-neutral-muted);"><code>call()</code></span>、<span style="background-color: var(--color-neutral-muted);"><code>apply()</code></span>和<span style="background-color: var(--color-neutral-muted);"><code>bind()</code></span>，它们的第一个参数是一个对象，它们会把这个对象绑定到<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>，接着在调用函数时让<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向这个对象。</p><p style="text-align: start;"><br></p><pre><code >var a = "makai";\n\nfunction func() {\n    console.log( this.a );\n}\nvar obj = {\n    a:"coffe1891"\n};\n\nfunc.call(obj); //&gt;&gt; coffe1891\n// 在调用 func 时强制把它的 this 绑定到 obj 上</code></pre><p style="text-align: start;">另外，使用<span style="background-color: var(--color-neutral-muted);"><code>bind</code></span>可以修正SetTimeout和SetInterval的this指向。还拿 <em>壹.2.3.4.1</em> 的代码演示：</p><p style="text-align: start;"><br></p><pre><code >var num = 0;\nclass Obj {\n    constructor(num){\n        this.num = num;\n    }\n    func(){\n        console.log(this.num);\n    }\n    func1(){\n        setTimeout(function () {\n            console.log("setTimeout:"+this.num);\n        }.bind(this), 1000);//bind\n    }\n    func2(){\n        setInterval(function () {\n            console.log(this.num);\n        }.bind(this), 2000);//bind\n    }\n}\nvar obj = new Obj(1);\nobj.func();//&gt;&gt; 1　             输出的是obj.num\nobj.func1()//&gt;&gt; setTimeout:1　  输出的是obj.num\nobj.func2()//&gt;&gt; 1 1 1 1 ……　    输出的是obj.num</code></pre><h3 style="text-align: start;">4. “new”操作符指向</h3><p style="text-align: start;">在JavaScript 中，<strong>构造函数</strong>只是一些<code><strong>使用new操作符时被调用的函数</strong></code>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<code><strong>只是被new操作符调用的普通函数而已</strong></code>。</p><p style="text-align: start;">使用<span style="background-color: var(--color-neutral-muted);"><code>new</code></span> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol style="text-align: start;"><li>创建（或者说构造）一个全新的对象；</li><li>将构造函数的作用域赋给新对象（因此<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li><li>如果函数没有返回其他对象，那么返回这个新对象。</li><li></li></ol><pre><code >function func(a) {\n    this.a = a;\n}\nvar bar = new func("coffe1891");\nconsole.log(bar.a); //&gt;&gt; coffe1891\n// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上\n</code></pre><h2 style="text-align: start;"> 如何利用规则判断this的指向</h2><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>this</code></span>的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则</p><h3 style="text-align: start;">1. 函数是否在<span style="background-color: var(--color-neutral-muted);"><code>new</code></span> 中被调用（<span style="background-color: var(--color-neutral-muted);"><code>new</code></span> 操作符指向）？</h3><p style="text-align: start;">如果是的话，<code><strong>this 绑定的是新创建的对象</strong></code>。</p><p style="text-align: start;"><br></p><pre><code >function func(name) {\n  this.name = name;\n  this.getName = function() {\n    return this.name;\n  };\n}\n\nvar obj = new func("coffe"); //this会指向obj\nconsole.log(obj.getName()); //&gt;&gt; coffe</code></pre><h3 style="text-align: start;">2. 函数是否通过<span style="background-color: var(--color-neutral-muted);"><code>call</code></span>、<span style="background-color: var(--color-neutral-muted);"><code>apply</code></span>、<span style="background-color: var(--color-neutral-muted);"><code>bind</code></span>显式指向？</h3><p style="text-align: start;">如果是的话，<code><strong>this指向的是call、apply、bind三个方法的第一个参数指定的对象</strong></code>。</p><p style="text-align: start;"><br></p><pre><code >var obj1 = {\n  name: "coffe"\n};\nfunction func() {\n  return this.name; //这里的this本来指向window\n}\nvar str = func.call(obj1); //改变了func函数里面this的指向，指向obj1\nconsole.log(str); //&gt;&gt; coffe</code></pre><h3 style="text-align: start;">3. 函数是否被当做某个对象的方法而调用（隐式指向）？</h3><p style="text-align: start;">如果是的话，<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向的是这个对象。</p><p style="text-align: start;"><br></p><pre><code >var obj1 = {\n  name: "coffe",\n  func() {\n    return this.name; //指向obj1\n  }\n};\n\n//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1\nconsole.log(obj1.func()); //&gt;&gt; coffe</code></pre><h3 style="text-align: start;">4. 若以上都不是的话，使用默认绑定。</h3><p style="text-align: start;">如果在严格模式下，就绑定到<span style="background-color: var(--color-neutral-muted);"><code>undefined</code></span>，否则绑定到<strong>全局对象</strong>。</p><p style="text-align: start;"><br></p><pre><code >var a = "coffe"; //为全局对象window添加一个属性a\nfunction func() {\n  "use strict";//开启严格模式\n  return this.a;\n}\n\n//严格模式下，this指向undefined\nconsole.log(func()); //&gt;&gt; TypeError</code></pre><h3 style="text-align: start;">1. 被忽略的this</h3><p style="text-align: start;"><span style="background-color: var(--color-neutral-muted);"><code>null</code></span> 或者<span style="background-color: var(--color-neutral-muted);"><code>undefined</code></span>作为<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>指向的对象传入<span style="background-color: var(--color-neutral-muted);"><code>call</code></span>、<span style="background-color: var(--color-neutral-muted);"><code>apply</code></span>或者<span style="background-color: var(--color-neutral-muted);"><code>bind</code></span>，这些值在调用时会被忽略，实际应用的是<strong>默认指向规则</strong>。</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  console.log(this.a);\n}\n\nvar a = 2;\nfunc.call(null); //&gt;&gt; 2\n                 //this指向了window</code></pre><h3 style="text-align: start;">2. 隐式指向之隐式丢失</h3><p style="text-align: start;"><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。下面再举一段更具迷惑性的例子：</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  console.log(this.a);\n}\nvar a = 2;\nvar o = { a: 3, func: func };\nvar p = { a: 4 };\no.func(); //&gt;&gt; 3\n(p.func = o.func)(); //&gt;&gt; 2\n// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用\n// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</code></pre><h3 style="text-align: start;">3. 箭头函数</h3><p style="text-align: start;">箭头函数并不是使用<span style="background-color: var(--color-neutral-muted);"><code>function</code></span>关键字定义的，而是使用被称为“胖箭头”的操作符 <span style="background-color: var(--color-neutral-muted);"><code>=&gt;</code></span> 定义的。</p><p style="text-align: start;">箭头函数不遵守<span style="background-color: var(--color-neutral-muted);"><code>this</code></span>的四种指向规则，而是<code><strong>根据函数定义时的作用域来决定 this 的指向</strong></code>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p><p style="text-align: start;">看下面代码加深理解：</p><p style="text-align: start;"><br></p><pre><code >function func() {\n  // 返回一个箭头函数\n  return a =&gt; {\n    //this 继承自 func()\n    console.log(this.a);\n  };\n}\nvar obj1 = {\n  a: 2\n};\nvar obj2 = {\n  a: 3\n};\n\nvar bar = func.call(obj1);\nbar.call(obj2); //&gt;&gt; 2         不是 3 ！\n\n// func() 内部创建的箭头函数会捕获调用时 func() 的 this。\n// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，\n// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</code></pre><p style="text-align: start;">这个特性甚至被mozilla的MDN称作“<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="">没有this</a>”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 &nbsp;。</p><p><br></p>', '2022-09-28 05:42:49', 0, 1, NULL, 1, 'this 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下', '博文', '2022/9/26 16:08:12'),
(32, 'socket.io服务怎么部署在线上node服务器上', '<p>本地开启了一个websoceket服务，并且node服务也开启了跨域请求，这是线上所并没有的</p><p><img src="/upload/img-xuewu1664442589867.png" alt="" data-href="" style=""/></p><p>部署的node服务器上一般会经历</p><p>1. http不能请求到https协议上，</p><p>前端请求的socket地址url产生协议错误，这个一般后端的真实地址，并还得设置服务器代理，</p><p><img src="/upload/img-xuewu1664443186606.png" alt="" data-href="" style=""/></p><p>2 socket请求到的服务器502，</p><p>服务器代理配置错误</p><p>3. socket请求发生错误404,</p><p>转发接口没有请求到真的接口地址</p><p><img src="/upload/img-xuewu1664443013623.png" alt="" data-href="" style=""/></p><p><br></p><p>如果要<span style="color: rgb(255, 169, 64);">部署在node的线上服务器的话，就要加上nginx配置代理，吧socket.io请求转发打到node部署的地址上</span></p><p><img src="/upload/img-xuewu1664442725317.png" alt="" data-href="" style=""/></p><p><br></p><p>通过以上的配置经历，这样就是的socket.io能在node线上服务生效！</p><p> &nbsp; &nbsp; &nbsp; 后面在有问题，在一一记录下？</p>', '2022-10-02 02:36:45', 0, 1, NULL, 1, '有些坑就，之所以能在本地服务器上面跑，是因为本地加入了webwocekt服务，node他能直接的连到你与你启动的本地项目端口，并开启一个连接', '博文', '2022/9/29 17:23:02'),
(33, '小农经济', '<p> &nbsp; &nbsp; &nbsp;为何要发展小农经济，是因为日益凸显的经济增长发展不平衡，农民生活经济开支不平衡，导致的农村经济收益持续下降。<img src="/upload/img-xuewu1666019526805.jpeg" alt="" data-href="" style=""/></p><p>学生开支、婴儿成长费用持续上升，现在面临着农村经济只够日常生活，其他收入进项，存款率下降，农村土地利用率不高、转化率没有效益，农村缺乏劳动力，农村经济发展没有新血液，就造成了农民健康生活、精神状态、农村文化改变的突剧。在日益增长的经济发展，收入和支出有了持平的趋势，现如今如何走出农村经济，摆脱精神文化交流成了一大障碍。</p><p> &nbsp; &nbsp;成因种种，面对如此状况？现如今的我们该如何破开这个局面，成了我们一大难题。有人说：农村经济搞经纪人管理体制，让专业的人搞专业的农业，这也出现了一个弊端，经济人体制，是必然会出现农村经济模式，所有农产品统一种植，开发售卖，很可能就会导致农村产业链统一化，农村经济发展走向了城市经济规划。</p><p> &nbsp; &nbsp;农村经济该如何面对，互联网➕农村优势➕新血液➕地方管理，走出去，互联通，是农村经济的一条路线！</p><p><img src="/upload/img-xuewu1666020916099.jpeg" alt="" data-href="" style=""/></p><p> &nbsp; 农村经济发展潜力，是一个发展的突破口，走好这条路线。精神文化建设的刚需，旅游业的兴起，地方人交流频繁，农村产业结构调整。</p>', '2022-10-17 16:30:58', 0, 3, NULL, 5, '发展小农经济，从农村包围城市', '兴趣', '2022/10/17 下午11:44:10');

-- --------------------------------------------------------

--
-- 表的结构 `category`
--

CREATE TABLE IF NOT EXISTS `category` (
  `id` int(11) NOT NULL COMMENT '编号',
  `name` varchar(50) COLLATE utf8_unicode_ci NOT NULL COMMENT '类目名称',
  `index` int(11) NOT NULL DEFAULT '0' COMMENT '排序，值越大越靠前'
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='文章类目表';

-- --------------------------------------------------------

--
-- 表的结构 `log`
--

CREATE TABLE IF NOT EXISTS `log` (
  `id` int(11) NOT NULL COMMENT '编号',
  `handle` varchar(50) COLLATE utf8_unicode_ci NOT NULL COMMENT '操作内容',
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '操作时间',
  `ip` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '来源IP'
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='日志表';

--
-- 转存表中的数据 `log`
--

INSERT INTO `log` (`id`, `handle`, `time`, `ip`) VALUES
(21, '登录', '2022-09-06 07:23:00', NULL);

-- --------------------------------------------------------

--
-- 表的结构 `pictures`
--

CREATE TABLE IF NOT EXISTS `pictures` (
  `islarge` bit(1) NOT NULL,
  `picture` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `id` int(11) NOT NULL,
  `thumbnail` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

--
-- 转存表中的数据 `pictures`
--

INSERT INTO `pictures` (`islarge`, `picture`, `id`, `thumbnail`) VALUES
(b'1', '第四套视觉陌生感-bjrg-elise ', 1, 'https://img2.baidu.com/it/u=43295762,3174535674&fm=253&fmt=auto&app=138&f=JPEG?w=658&h=438'),
(b'1', '2022年最新免签名单', 2, 'https://img1.baidu.com/it/u=640067450,1349297086&fm=253&fmt=auto&app=138&f=JPEG?w=909&h=500'),
(b'0', '托普岛(tup island)图片', 3, 'https://img2.baidu.com/it/u=1205373002,2667858918&fm=253&fmt=auto&app=138&f=JPEG?w=779&h=500'),
(b'0', '不爱绣球你一定是没去过tupare', 4, 'https://img1.baidu.com/it/u=3078839842,1528260431&fm=253&fmt=auto&app=138&f=JPEG?w=658&h=368');

-- --------------------------------------------------------

--
-- 表的结构 `riddle`
--

CREATE TABLE IF NOT EXISTS `riddle` (
  `id` int(11) NOT NULL COMMENT '猜谜',
  `title` varchar(255) CHARACTER SET utf8 NOT NULL COMMENT '标题',
  `puzzle` varchar(255) CHARACTER SET utf8 NOT NULL,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '上传时间',
  `hot` tinyint(1) NOT NULL DEFAULT '0' COMMENT '0:非热门1:热门',
  `hits` int(11) NOT NULL DEFAULT '0' COMMENT '点击量',
  `thumbnail` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '缩略图',
  `category` int(11) NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 DEFAULT '' COMMENT '描述',
  `tag` varchar(20) CHARACTER SET utf8 DEFAULT NULL COMMENT '标签',
  `errorlist` varchar(255) CHARACTER SET utf8 NOT NULL,
  `answer` varchar(100) CHARACTER SET utf8 NOT NULL,
  `creatTime` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '2022/9/18 17:39:12'
) ENGINE=InnoDB AUTO_INCREMENT=57 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='文章表';

--
-- 转存表中的数据 `riddle`
--

INSERT INTO `riddle` (`id`, `title`, `puzzle`, `time`, `hot`, `hits`, `thumbnail`, `category`, `description`, `tag`, `errorlist`, `answer`, `creatTime`) VALUES
(49, '小小怪出马', '远看像只猫，\n近看像只鸟，\n夜晚啄老鼠，\n白日睡大觉', '2022-09-17 10:25:15', 0, 0, NULL, 6, '应该难不倒你把', '猜谜语', ' 老鼠,星星,小猫', '猫头鹰', '2022/9/18 17:39:12'),
(50, '你这是好的什么？', '远看像只猫，\n近看像只鸟，\n夜晚啄老鼠，\n白日睡大觉', '2022-09-17 15:59:27', 0, 0, NULL, 6, '如果是这样，那么这是什么谜', '猜谜语', ' 老鼠,星星,小猫', '猫头鹰', '2022/9/18 17:39:12'),
(51, '哪这个是不是动物', '有头无颈，\n有眼无眉，\n无脚能走，\n有翅难飞', '2022-09-17 15:30:22', 0, 0, NULL, 6, '是不是动物，你不会思考？', '猜谜语', '鸵鸟,飞鱼,蝌蚪', '鱼', '2022/9/18 17:39:12'),
(52, '为啥小小年纪就有胡子啦？', '小小年纪，\n却有胡子一把，\n不论谁见，\n总是大呼妈妈', '2022-09-17 15:38:19', 0, 0, NULL, 6, '你说，这是不是年纪没老，心却老了呢', '猜谜语', '猫,青蛙,树叶,人', '羊', '2022/9/18 17:39:12'),
(53, '你这是一个有趣的舌头，舌战群儒', '一个黑孩，\n从不开口，\n要是开口，\n掉出舌头', '2022-09-19 06:55:02', 1, 0, NULL, 6, '故立志者，为学之心也；为学者，立志之事也，倒是细细的想一下啊', '猜谜语', '食人花,小黑,小蛇', '瓜籽', '2022/9/18 17:39:12'),
(54, '姑娘不要怕，我来替你扛枪', '有位小姑娘，\n身穿黄衣裳。\n谁要欺负她，\n她就戳一枪', '2022-09-20 07:17:21', 1, 0, NULL, 6, '他这么小，你忍心欺辱她吗', '猜谜语', '油菜花,荷茎,黄鹂,小黄', '黄蜂', '2022/9/18 17:39:12'),
(55, '这个要做什么', '坐也是立，立也是立，行也是立，卧也是立', '2022-09-20 15:57:50', 0, 0, NULL, 6, '不喜，不动，不欢，不气，不争', '猜谜语', '菜鸟,乌龟,猴子,坐立不安', '马', '2022/9/20 23:57:49'),
(56, '打哑谜？', ' 一家有七口，\n种田种一亩，\n自己吃不够，\n还养一条狗', '2022-09-23 14:02:16', 1, 0, NULL, 6, '为啥自己都不够吃，还要去养一条狗啊，种田，七口，不够吃，狗', '猜谜语', '亩,人,禽,鱼', '兽', '2022/9/23 22:02:15');

-- --------------------------------------------------------

--
-- 表的结构 `users`
--

CREATE TABLE IF NOT EXISTS `users` (
  `id` int(11) NOT NULL COMMENT '用户id',
  `username` varchar(100) COLLATE utf8_unicode_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) COLLATE utf8_unicode_ci NOT NULL COMMENT '密码',
  `age` int(11) DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='用户表';

--
-- 转存表中的数据 `users`
--

INSERT INTO `users` (`id`, `username`, `password`, `age`, `avatar`) VALUES
(1, 'admin', '123456', NULL, 'https://img2.baidu.com/it/u=390829681,3002818272&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500'),
(2, 'guest', 'guest', NULL, 'https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png'),
(3, 'clound', '123456', NULL, NULL),
(5, '张瀚', '123456', NULL, NULL);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `article`
--
ALTER TABLE `article`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `category`
--
ALTER TABLE `category`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `log`
--
ALTER TABLE `log`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `pictures`
--
ALTER TABLE `pictures`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `riddle`
--
ALTER TABLE `riddle`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `article`
--
ALTER TABLE `article`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=34;
--
-- AUTO_INCREMENT for table `category`
--
ALTER TABLE `category`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '编号',AUTO_INCREMENT=7;
--
-- AUTO_INCREMENT for table `log`
--
ALTER TABLE `log`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '编号',AUTO_INCREMENT=22;
--
-- AUTO_INCREMENT for table `pictures`
--
ALTER TABLE `pictures`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=7;
--
-- AUTO_INCREMENT for table `riddle`
--
ALTER TABLE `riddle`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '猜谜',AUTO_INCREMENT=57;
--
-- AUTO_INCREMENT for table `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',AUTO_INCREMENT=6;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
